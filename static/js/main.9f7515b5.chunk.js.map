{"version":3,"sources":["search/SearchMap.ts","search/utils/Vec2d.ts","search/methods/bidirectional-bfs.ts","search/index.ts","search/utils/Queue.ts","search/methods/breadth-first-search.ts","PathFinder.tsx","search/methods/index.ts","utils/sleep.ts","index.tsx"],"names":["Square","Vec2d","x","y","v","this","Direction","nodeHistory","SearchMap","numCols","numRows","squares","push","Array","fill","Empty","pos","square","isWithinBounds","Error","toString","map","neighbours","dx","dy","neighbour","add","isEmpty","length","rewind","node","path","prev","unshift","Queue","items","shift","size","bfs","name","start","target","visited","Set","queue","searchNode","dequeue","current","found","equals","getNeighbours","neighbourPos","hash","has","enqueue","f","MovingState","methods","breadthFirstSearch","visitedForward","visitedBackward","direction","Forward","Backward","neighbourNode","intersection","filter","sort","defaultRewind","reverse","sleep","ms","a","Promise","r","setTimeout","getInitialMap","cols","rows","getInitialStart","Math","floor","getInitialTarget","getInitialVisited","getInitialSolution","PathFinder","mapSize","mapStyles","useState","setMap","setStart","setTarget","setVisited","solution","setSolution","method","setMethod","None","moving","setMoving","isDrawing","setIsDrawing","handleMouseDown","Start","Target","withSquare","Wall","handleMouseEnter","handleStartClick","getClassName","className","onClick","onChange","e","value","Object","entries","key","style","onMouseUp","onMouseDown","onMouseEnter","buildMapSquares","ReactDOM","render","StrictMode","bodyPadding","parseInt","getComputedStyle","document","body","getPropertyValue","headerHeight","querySelector","squareWidth","documentElement","window","innerWidth","innerHeight","gridTemplateColumns","gridTemplateRows","buildPathFinderProps","getElementById"],"mappings":"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","file":"static/js/main.9f7515b5.chunk.js","sourcesContent":["import Vec2d from \"./utils/Vec2d\";\n\nexport enum Square {\n  Empty,\n  Wall,\n}\n\nexport default class SearchMap {\n  private squares: Square[][] = [];\n\n  public constructor(numCols: number, numRows: number) {\n    while (numRows--) {\n      this.squares.push(Array(numCols).fill(Square.Empty));\n    }\n  }\n\n  public withSquare(pos: Vec2d, square: Square): SearchMap {\n    if (!this.isWithinBounds(pos)) {\n      throw new Error(`Out of bounds: ${pos.toString()}`);\n    }\n\n    const map = new SearchMap(this.numCols, this.numRows);\n\n    map.squares = this.squares;\n    map.squares[pos.y][pos.x] = square;\n\n    return map;\n  }\n\n  public isEmpty(pos: Vec2d): boolean {\n    return this.squares[pos.y][pos.x] === Square.Empty;\n  }\n\n  public getNeighbours(pos: Vec2d): Vec2d[] {\n    const neighbours = [];\n\n    const dirs = [\n      { dx: 1, dy: 0 },\n      { dx: 0, dy: 1 },\n      { dx: -1, dy: 0 },\n      { dx: 0, dy: -1 },\n    ];\n\n    for (const { dx, dy } of dirs) {\n      const neighbour = pos.add(new Vec2d(dx, dy));\n\n      if (!this.isWithinBounds(neighbour)) {\n        continue;\n      }\n\n      if (this.isEmpty(neighbour)) {\n        neighbours.push(neighbour);\n      }\n    }\n\n    return neighbours;\n  }\n\n  private isWithinBounds(pos: Vec2d): boolean {\n    return pos.x >= 0 && pos.y >= 0 && pos.x < this.numCols && pos.y < this.numRows;\n  }\n\n  public get numCols(): number {\n    return this.squares[0].length;\n  }\n\n  public get numRows(): number {\n    return this.squares.length;\n  }\n}\n","export default class Vec2d {\n  constructor(readonly x: number, readonly y: number) {}\n\n  public add(v: Vec2d): Vec2d {\n    return new Vec2d(this.x + v.x, this.y + v.y);\n  }\n\n  public equals(v: Vec2d): boolean {\n    return this.x === v.x && this.y === v.y;\n  }\n\n  public toString(): string {\n    return `(${this.x}, ${this.y})`;\n  }\n}\n","import { SearchState, SearchNode, SearchParams, SearchMethod, rewind as defaultRewind } from \"../\";\nimport Queue from \"../utils/Queue\";\nimport Vec2d from \"../utils/Vec2d\";\n\nenum Direction {\n  Forward,\n  Backward,\n}\n\ntype BiDirSearchNode = {\n  searchNode: SearchNode;\n  direction: Direction;\n};\n\nlet nodeHistory: BiDirSearchNode[];\n\nconst start = function* ({ map, start, target }: SearchParams): Generator<SearchState> {\n  nodeHistory = [];\n\n  const visitedForward = new Set<string>([start.toString()]);\n  const visitedBackward = new Set<string>([target.toString()]);\n\n  const queue = new Queue<BiDirSearchNode>([\n    {\n      searchNode: { pos: start },\n      direction: Direction.Forward,\n    },\n    {\n      searchNode: { pos: target },\n      direction: Direction.Backward,\n    },\n  ]);\n\n  while (!queue.isEmpty()) {\n    const { searchNode, direction } = queue.dequeue() as BiDirSearchNode;\n\n    const found =\n      (direction === Direction.Forward && visitedBackward.has(searchNode.pos.toString())) ||\n      (direction === Direction.Backward && visitedForward.has(searchNode.pos.toString()));\n\n    yield { current: searchNode, visited: new Set([...visitedForward, ...visitedBackward]), found };\n\n    for (const neighbourPos of map.getNeighbours(searchNode.pos)) {\n      const hash = neighbourPos.toString();\n      let enqueue = false;\n\n      if (direction === Direction.Forward) {\n        if (!visitedForward.has(hash)) {\n          visitedForward.add(hash);\n          enqueue = true;\n        }\n      } else if (!visitedBackward.has(hash)) {\n        visitedBackward.add(hash);\n        enqueue = true;\n      }\n\n      if (enqueue) {\n        const neighbourNode = {\n          searchNode: {\n            pos: neighbourPos,\n            prev: searchNode,\n          },\n          direction,\n        };\n\n        nodeHistory.push(neighbourNode);\n        queue.enqueue(neighbourNode);\n      }\n    }\n  }\n};\n\nconst rewind = (node: SearchNode): Vec2d[] => {\n  const intersection = nodeHistory\n    .filter(({ searchNode }) => node.pos.equals(searchNode.pos))\n    .sort(({ direction }) => (direction === Direction.Forward ? -1 : 1));\n\n  return [...defaultRewind(intersection[0].searchNode), ...defaultRewind(intersection[1].searchNode).reverse()];\n};\n\nconst biDirBfs: SearchMethod = { name: \"Bidirectional BFS\", start, rewind };\n\nexport default biDirBfs;\n","import SearchMap from \"./SearchMap\";\nimport Vec2d from \"./utils/Vec2d\";\n\nexport type SearchParams = {\n  map: SearchMap;\n  start: Vec2d;\n  target: Vec2d;\n};\n\nexport type SearchNode = {\n  pos: Vec2d;\n  prev?: SearchNode;\n};\n\nexport type SearchState = {\n  current: SearchNode;\n  visited: Set<string>;\n  found: boolean;\n};\n\nexport type SearchMethod = {\n  name: string;\n  start: (params: SearchParams) => Generator<SearchState>;\n  rewind: (node: SearchNode) => Vec2d[];\n};\n\nexport const rewind = (node: SearchNode): Vec2d[] => {\n  const path = [];\n\n  while (node.prev) {\n    path.unshift(node.pos);\n    node = node.prev;\n  }\n\n  return path;\n};\n","export default class Queue<T> {\n  constructor(private items: T[] = []) {}\n\n  public enqueue(...items: T[]): void {\n    this.items.push(...items);\n  }\n\n  public dequeue(): T | undefined {\n    return this.items.shift();\n  }\n\n  public isEmpty(): boolean {\n    return this.size === 0;\n  }\n\n  public get size(): number {\n    return this.items.length;\n  }\n}\n","import { SearchState, SearchNode, SearchParams, SearchMethod, rewind } from \"../\";\nimport Queue from \"../utils/Queue\";\n\nconst start = function* ({ map, start, target }: SearchParams): Generator<SearchState> {\n  const visited = new Set<string>([start.toString()]);\n  const queue = new Queue<SearchNode>([{ pos: start }]);\n\n  while (!queue.isEmpty()) {\n    const searchNode = queue.dequeue() as SearchNode;\n\n    yield { current: searchNode, visited, found: searchNode.pos.equals(target) };\n\n    for (const neighbourPos of map.getNeighbours(searchNode.pos)) {\n      const hash = neighbourPos.toString();\n\n      if (!visited.has(hash)) {\n        visited.add(hash);\n        queue.enqueue({\n          pos: neighbourPos,\n          prev: searchNode,\n        });\n      }\n    }\n  }\n};\n\nconst bfs: SearchMethod = { name: \"Breadth First Search\", start, rewind };\n\nexport default bfs;\n","import { useState, CSSProperties } from \"react\";\nimport SearchMap, { Square } from \"./search/SearchMap\";\nimport methods from \"./search/methods\";\nimport Vec2d from \"./search/utils/Vec2d\";\nimport sleep from \"./utils/sleep\";\n\ntype PathFinderProps = {\n  mapSize: {\n    cols: number;\n    rows: number;\n  };\n  mapStyles: CSSProperties;\n};\n\nenum MovingState {\n  None,\n  Start,\n  Target,\n}\n\nconst getInitialMap = (cols: number, rows: number) => new SearchMap(cols, rows);\nconst getInitialStart = (cols: number, rows: number) => new Vec2d(Math.floor(cols / 4) - 1, Math.floor(rows / 2) - 1);\nconst getInitialTarget = (cols: number, rows: number) => new Vec2d(cols - Math.floor(cols / 4), Math.floor(rows / 2) - 1);\nconst getInitialVisited = () => new Set<string>();\nconst getInitialSolution = () => new Set<string>();\n\nconst PathFinder = ({ mapSize: { cols, rows }, mapStyles }: PathFinderProps): JSX.Element => {\n  const [map, setMap] = useState(getInitialMap(cols, rows));\n  const [start, setStart] = useState(getInitialStart(cols, rows));\n  const [target, setTarget] = useState(getInitialTarget(cols, rows));\n  const [visited, setVisited] = useState(getInitialVisited());\n  const [solution, setSolution] = useState(getInitialSolution());\n\n  const [method, setMethod] = useState(\"breadth-first-search\");\n  const [moving, setMoving] = useState(MovingState.None);\n  const [isDrawing, setIsDrawing] = useState(false);\n\n  const handleMouseUp = (): void => {\n    setMoving(MovingState.None);\n    setIsDrawing(false);\n  };\n\n  const handleMouseDown = (pos: Vec2d): void => {\n    if (pos.equals(start)) {\n      setMoving(MovingState.Start);\n      return;\n    }\n\n    if (pos.equals(target)) {\n      setMoving(MovingState.Target);\n      return;\n    }\n\n    setIsDrawing(true);\n    setMap(map.withSquare(pos, map.isEmpty(pos) ? Square.Wall : Square.Empty));\n  };\n\n  const handleMouseEnter = (pos: Vec2d): void => {\n    if (moving === MovingState.Start) {\n      setStart(pos);\n      return;\n    }\n\n    if (moving === MovingState.Target) {\n      setTarget(pos);\n      return;\n    }\n\n    if (isDrawing) {\n      setMap(map.withSquare(pos, Square.Wall));\n    }\n  };\n\n  const handleStartClick = async (): Promise<void> => {\n    const solution = getInitialSolution();\n    setSolution(solution);\n\n    // @ts-ignore\n    for (const { current, found, visited } of methods[method].start({ map, start, target })) {\n      setVisited(new Set([...visited]));\n\n      if (found) {\n        // @ts-ignore\n        for (const pos of methods[method].rewind(current)) {\n          setSolution(new Set([...solution.add(pos.toString())]));\n          await sleep(20);\n        }\n\n        break;\n      }\n\n      await sleep(10);\n    }\n  };\n\n  const handleClearClick = (): void => {\n    setMap(getInitialMap(cols, rows));\n    setStart(getInitialStart(cols, rows));\n    setTarget(getInitialTarget(cols, rows));\n    setVisited(getInitialVisited());\n    setSolution(getInitialSolution());\n  };\n\n  const handleMethodSelect = (e: any): void => {\n    setMethod(e.target.value);\n  };\n\n  const getClassName = (pos: Vec2d): string => {\n    if (!map.isEmpty(pos)) {\n      return \"wall\";\n    }\n\n    if (start.equals(pos)) {\n      return \"start\";\n    }\n\n    if (target.equals(pos)) {\n      return \"target\";\n    }\n\n    if (solution.has(pos.toString())) {\n      return \"solution\";\n    }\n\n    if (visited.has(pos.toString())) {\n      return \"visited\";\n    }\n\n    return \"\";\n  };\n\n  const buildMapSquares = (): JSX.Element[] => {\n    const squares = [];\n\n    for (let y = 0; y < map.numRows; ++y) {\n      for (let x = 0; x < map.numCols; ++x) {\n        const pos = new Vec2d(x, y);\n\n        squares.push(\n          <div\n            key={pos.toString()}\n            className={getClassName(pos)}\n            onMouseUp={() => handleMouseUp()}\n            onMouseDown={() => handleMouseDown(pos)}\n            onMouseEnter={() => handleMouseEnter(pos)}\n          />\n        );\n      }\n    }\n\n    return squares;\n  };\n\n  return (\n    <div className=\"PathFinder\">\n      <div className=\"Controls\">\n        <button onClick={handleStartClick}>Start</button>\n        <button onClick={handleClearClick}>Clear</button>\n        <select onChange={handleMethodSelect}>\n          {Object.entries(methods).map(([key, method]) => (\n            <option key={key} value={key}>\n              {method.name}\n            </option>\n          ))}\n        </select>\n      </div>\n      <div className=\"Map\" style={mapStyles}>\n        {buildMapSquares()}\n      </div>\n    </div>\n  );\n};\n\nexport default PathFinder;\n","import breadthFirstSearch from \"./breadth-first-search\";\nimport biDirectionalBfs from \"./bidirectional-bfs\";\n\nconst methods = {\n  \"breadth-first-search\": breadthFirstSearch,\n  \"bidirectional-bfs\": biDirectionalBfs,\n};\n\nexport default methods;\n","const sleep = async (ms: number): Promise<void> => {\n  await new Promise((r) => setTimeout(r, ms));\n};\n\nexport default sleep;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport PathFinder from \"./PathFinder\";\nimport \"./index.css\";\n\nconst buildPathFinderProps = () => {\n  // @ts-ignore\n  const bodyPadding = parseInt(getComputedStyle(document.body).getPropertyValue(\"padding\"));\n  // @ts-ignore\n  const headerHeight = parseInt(getComputedStyle(document.querySelector(\"header\")).getPropertyValue(\"height\"));\n  const squareWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue(\"--map-square-width\"));\n\n  const cols = Math.floor((window.innerWidth - 2 * bodyPadding) / squareWidth);\n  const rows = Math.floor((window.innerHeight - 2 * headerHeight - bodyPadding) / squareWidth);\n\n  return {\n    mapSize: { cols, rows },\n    mapStyles: {\n      gridTemplateColumns: `repeat(${cols}, ${squareWidth}px)`,\n      gridTemplateRows: `repeat(${rows}, ${squareWidth}px)`,\n    },\n  };\n};\n\nReactDOM.render(\n  <React.StrictMode>\n    <PathFinder {...buildPathFinderProps()} />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n"],"sourceRoot":""}