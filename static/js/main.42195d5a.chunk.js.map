{"version":3,"sources":["search/methods/bidirectional-bfs.ts","utils/Vec2d.ts","maze/index.ts","maze/Maze.ts","maze/generators/index.ts","maze/generators/binary-tree.ts","maze/generators/random.ts","search/index.ts","search/methods/utils/Queue.ts","search/methods/breadth-first-search.ts","Components/PathFinder.tsx","search/methods/greedy-best-first-search.ts","search/methods/depth-first-search.ts","search/methods/index.ts","Components/utils/sleep.ts","Components/Controls.tsx","Components/Maze.tsx","index.tsx"],"names":["Direction","nodeHistory","Vec2d","x","y","v","this","from","to","Math","floor","random","getNeighbours","maze","pos","neighbours","dx","dy","neighbour","add","isWithinBounds","isWall","push","findEmptySquareInBounds","square","Maze","numCols","numRows","walls","Set","toggleWalls","positions","Error","toString","delete","has","generators","binaryTree","name","generate","cols","rows","row","col","wallLeftOrUp","toggleWall","rewind","node","path","prev","unshift","Queue","items","isEmpty","shift","size","length","bfs","start","target","visited","queue","dequeue","current","found","equals","hash","enqueue","f","MovingState","biDirBfs","visitedForward","visitedBackward","direction","Forward","Backward","neighbourNode","intersection","filter","n","sort","defaultRewind","reverse","manhattanDistance","a","b","abs","greedyBestFirstSearch","PriorityQueue","comparator","initialValues","dfs","params","methods","breadthFirstSearch","biDirectionalBfs","greedBestFirstSearch","depthFirstSearch","sleep","ms","Promise","r","setTimeout","Controls","props","className","onChange","onMazeGeneratorSelect","value","selectedMazeGenerator","Object","entries","mazeGenerators","map","key","generator","onClick","onGenerateClick","disabled","isRunning","onClearClick","onSearchMethodSelect","selectedSearchMethod","searchMethods","method","onStopClick","onStartClick","squares","getSquareClassName","onMouseUp","onMouseDown","onMouseEnter","style","getInitialMaze","getInitialStart","getInitialTarget","getInitialVisited","getInitialSolution","PathFinder","mazeSize","mazeStyle","useState","setMaze","setStart","setTarget","setVisited","solution","setSolution","None","moving","setMoving","isDrawing","setIsDrawing","Date","now","setFinishedAt","mazeGenerator","setMazeGenerator","searchMethod","setSearchMethod","currentSearch","useRef","setCurrentSearch","s","running","setIsRunning","handleStartClick","generateSearch","next","done","state","handleClearClick","origin","e","Start","Target","ReactDOM","render","StrictMode","bodyPadding","parseInt","getComputedStyle","document","body","getPropertyValue","headerHeight","querySelector","squareWidth","documentElement","window","innerWidth","max","innerHeight","gridTemplateColumns","gridTemplateRows","buildPathFinderProps","getElementById"],"mappings":"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","file":"static/js/main.42195d5a.chunk.js","sourcesContent":["import { SearchNode, SearchParams, SearchState, rewind as defaultRewind } from \"../\";\nimport { getNeighbours } from \"../../maze\";\nimport Queue from \"./utils/Queue\";\nimport Vec2d from \"../../utils/Vec2d\";\n\nenum Direction {\n  Forward,\n  Backward,\n}\n\ntype BiDirSearchNode = {\n  node: SearchNode;\n  direction: Direction;\n};\n\nlet nodeHistory: BiDirSearchNode[];\n\nconst start = function* ({ maze, start, target }: SearchParams): Generator<SearchState> {\n  nodeHistory = [];\n\n  const visitedForward = new Set<string>([start.toString()]);\n  const visitedBackward = new Set<string>([target.toString()]);\n\n  const queue = new Queue<BiDirSearchNode>([\n    {\n      node: { pos: start },\n      direction: Direction.Forward,\n    },\n    {\n      node: { pos: target },\n      direction: Direction.Backward,\n    },\n  ]);\n\n  while (!queue.isEmpty()) {\n    const { node, direction } = queue.dequeue();\n\n    const found =\n      (direction === Direction.Forward && visitedBackward.has(node.pos.toString())) ||\n      (direction === Direction.Backward && visitedForward.has(node.pos.toString()));\n\n    yield { current: node, visited: new Set([...visitedForward, ...visitedBackward]), found };\n\n    for (const neighbour of getNeighbours(maze, node.pos)) {\n      const hash = neighbour.toString();\n      let enqueue = false;\n\n      if (direction === Direction.Forward) {\n        if (!visitedForward.has(hash)) {\n          visitedForward.add(hash);\n          enqueue = true;\n        }\n      } else if (!visitedBackward.has(hash)) {\n        visitedBackward.add(hash);\n        enqueue = true;\n      }\n\n      if (enqueue) {\n        const neighbourNode = {\n          node: {\n            pos: neighbour,\n            prev: node,\n          },\n          direction,\n        };\n\n        nodeHistory.push(neighbourNode);\n        queue.enqueue(neighbourNode);\n      }\n    }\n  }\n};\n\nconst rewind = (node: SearchNode): Vec2d[] => {\n  const intersection = nodeHistory\n    .filter(({ node: n }) => node.pos.equals(n.pos))\n    .sort(({ direction }) => (direction === Direction.Forward ? -1 : 1));\n\n  return [...defaultRewind(intersection[0].node), ...defaultRewind(intersection[1].node).reverse()];\n};\n\nconst biDirBfs = { name: \"Bidirectional BFS\", start, rewind };\n\nexport default biDirBfs;\n","export default class Vec2d {\n  constructor(readonly x: number, readonly y: number) {}\n\n  public add(v: Vec2d): Vec2d {\n    return new Vec2d(this.x + v.x, this.y + v.y);\n  }\n\n  public equals(v: Vec2d): boolean {\n    return this.x === v.x && this.y === v.y;\n  }\n\n  public toString(): string {\n    return `(${this.x}, ${this.y})`;\n  }\n\n  public static origin(): Vec2d {\n    return new Vec2d(0, 0);\n  }\n\n  public static random(from: Vec2d, to: Vec2d): Vec2d {\n    return new Vec2d(\n      Math.floor(from.x + Math.random() * (to.x - from.x)),\n      Math.floor(from.y + Math.random() * (to.y - from.y))\n    );\n  }\n}\n","import Maze from \"./Maze\";\nimport Vec2d from \"../utils/Vec2d\";\n\nexport const getNeighbours = (maze: Maze, pos: Vec2d): Vec2d[] => {\n  const neighbours = [];\n\n  const dirs = [\n    { dx: 1, dy: 0 },\n    { dx: 0, dy: 1 },\n    { dx: -1, dy: 0 },\n    { dx: 0, dy: -1 },\n  ];\n\n  for (const { dx, dy } of dirs) {\n    const neighbour = pos.add(new Vec2d(dx, dy));\n\n    if (maze.isWithinBounds(neighbour) && !maze.isWall(neighbour)) {\n      neighbours.push(neighbour);\n    }\n  }\n\n  return neighbours;\n};\n\nexport const findEmptySquareInBounds = (maze: Maze, from: Vec2d, to: Vec2d): Vec2d => {\n  let square;\n\n  do square = Vec2d.random(from, to);\n  while (maze.isWall(square));\n\n  return square;\n};\n","import Vec2d from \"../utils/Vec2d\";\n\nexport default class Maze {\n  private walls = new Set<string>();\n\n  public constructor(readonly numCols: number, readonly numRows: number) {}\n\n  public toggleWall(pos: Vec2d): Maze {\n    return this.toggleWalls([pos]);\n  }\n\n  public toggleWalls(positions: Vec2d[]): Maze {\n    const maze = new Maze(this.numCols, this.numRows);\n    maze.walls = new Set([...this.walls]);\n\n    for (const pos of positions) {\n      if (!this.isWithinBounds(pos)) {\n        throw new Error(`Out of bounds: ${pos.toString()}`);\n      }\n\n      if (maze.isWall(pos)) {\n        maze.walls.delete(pos.toString());\n      } else {\n        maze.walls.add(pos.toString());\n      }\n    }\n\n    return maze;\n  }\n\n  public isWall(pos: Vec2d): boolean {\n    return this.walls.has(pos.toString());\n  }\n\n  public isWithinBounds(pos: Vec2d): boolean {\n    return pos.x >= 0 && pos.y >= 0 && pos.x < this.numCols && pos.y < this.numRows;\n  }\n}\n","import Maze from \"../Maze\";\nimport binaryTree from \"./binary-tree\";\nimport random from \"./random\";\n\ntype MazeGenerator = {\n  name: string;\n  generate: (cols: number, rows: number) => Maze;\n};\n\nconst generators: { [key: string]: MazeGenerator } = { binaryTree, random };\n\nexport default generators;\n","import Maze from \"../Maze\";\nimport Vec2d from \"../../utils/Vec2d\";\n\nconst generate = (cols: number, rows: number): Maze => {\n  let maze = new Maze(cols, rows);\n\n  for (let row = 2; row < rows; row += 2) {\n    for (let col = 2; col < cols; col += 2) {\n      const wallLeftOrUp = [new Vec2d(col - 1, row), new Vec2d(col, row - 1)];\n      maze = maze.toggleWalls([wallLeftOrUp[Math.floor(Math.random() * 2)], new Vec2d(col - 1, row - 1)]);\n    }\n  }\n\n  return maze;\n};\n\nconst random = { name: \"Binary tree\", generate };\n\nexport default random;\n","import Maze from \"../Maze\";\nimport Vec2d from \"../../utils/Vec2d\";\n\nconst generate = (cols: number, rows: number): Maze => {\n  let maze = new Maze(cols, rows);\n\n  for (let row = 0; row < rows; ++row) {\n    for (let col = 0; col < cols; ++col) {\n      if (Math.random() < 0.25) {\n        maze = maze.toggleWall(new Vec2d(col, row));\n      }\n    }\n  }\n\n  return maze;\n};\n\nconst random = { name: \"Random\", generate };\n\nexport default random;\n","import Maze from \"../maze/Maze\";\nimport Vec2d from \"../utils/Vec2d\";\n\nexport type SearchParams = {\n  maze: Maze;\n  start: Vec2d;\n  target: Vec2d;\n};\n\nexport type SearchNode = {\n  pos: Vec2d;\n  prev?: SearchNode;\n};\n\nexport type SearchState = {\n  current: SearchNode;\n  visited: Set<string>;\n  found: boolean;\n};\n\nexport const rewind = (node: SearchNode): Vec2d[] => {\n  const path = [];\n\n  while (node.prev) {\n    path.unshift(node.pos);\n    node = node.prev;\n  }\n\n  return path;\n};\n","export default class Queue<T> {\n  constructor(private items: T[] = []) {}\n\n  public enqueue(...items: T[]): void {\n    this.items.push(...items);\n  }\n\n  public dequeue(): T {\n    if (this.isEmpty()) {\n      throw new Error(\"Cannot dequeue empty queue\");\n    }\n\n    return this.items.shift() as T;\n  }\n\n  public isEmpty(): boolean {\n    return this.size === 0;\n  }\n\n  public get size(): number {\n    return this.items.length;\n  }\n}\n","import { SearchNode, SearchParams, SearchState, rewind } from \"../\";\nimport { getNeighbours } from \"../../maze\";\nimport Queue from \"./utils/Queue\";\n\nconst start = function* ({ maze, start, target }: SearchParams): Generator<SearchState> {\n  const visited = new Set<string>([start.toString()]);\n  const queue = new Queue<SearchNode>([{ pos: start }]);\n\n  while (!queue.isEmpty()) {\n    const node = queue.dequeue();\n\n    yield { current: node, visited, found: node.pos.equals(target) };\n\n    for (const neighbour of getNeighbours(maze, node.pos)) {\n      const hash = neighbour.toString();\n\n      if (!visited.has(hash)) {\n        visited.add(hash);\n        queue.enqueue({ pos: neighbour, prev: node });\n      }\n    }\n  }\n};\n\nconst bfs = { name: \"Breadth-first search\", start, rewind };\n\nexport default bfs;\n","import React, { useRef, useState } from \"react\";\nimport { findEmptySquareInBounds } from \"../maze\";\nimport Maze from \"../maze/Maze\";\nimport mazeGenerators from \"../maze/generators\";\nimport searchMethods from \"../search/methods\";\nimport Vec2d from \"../utils/Vec2d\";\nimport sleep from \"./utils/sleep\";\nimport Controls from \"./Controls\";\nimport MazeComponent from \"./Maze\";\n\ntype PathFinderProps = {\n  mazeSize: {\n    cols: number;\n    rows: number;\n  };\n  mazeStyle: React.CSSProperties;\n};\n\nenum MovingState {\n  None,\n  Start,\n  Target,\n}\n\nconst getInitialMaze = (cols: number, rows: number) => new Maze(cols, rows);\nconst getInitialStart = (cols: number, rows: number) => new Vec2d(Math.floor(cols / 4) - 1, Math.floor(rows / 2));\nconst getInitialTarget = (cols: number, rows: number) => new Vec2d(cols - Math.floor(cols / 4), Math.floor(rows / 2));\nconst getInitialVisited = () => new Set<string>();\nconst getInitialSolution = () => new Set<string>();\n\nconst PathFinder = ({ mazeSize: { cols, rows }, mazeStyle }: PathFinderProps): JSX.Element => {\n  const [maze, setMaze] = useState(getInitialMaze(cols, rows));\n  const [start, setStart] = useState(getInitialStart(cols, rows));\n  const [target, setTarget] = useState(getInitialTarget(cols, rows));\n  const [visited, setVisited] = useState(getInitialVisited());\n  const [solution, setSolution] = useState(getInitialSolution());\n\n  const [moving, setMoving] = useState(MovingState.None);\n  const [isDrawing, setIsDrawing] = useState(false);\n  const [, setFinishedAt] = useState(Date.now);\n\n  const [mazeGenerator, setMazeGenerator] = useState(\"binaryTree\");\n  const [searchMethod, setSearchMethod] = useState(\"breadthFirstSearch\");\n\n  const currentSearch = useRef<Generator | null>(null);\n  const hasCurrentSearch = (): boolean => currentSearch.current !== null;\n  const setCurrentSearch = (s: Generator | null): void => void (currentSearch.current = s);\n\n  const running = useRef(false);\n  const isRunning = (): boolean => running.current;\n  const setIsRunning = (r: boolean): void => void (running.current = r);\n\n  const handleMouseUp = (): void => {\n    setMoving(MovingState.None);\n    setIsDrawing(false);\n  };\n\n  const handleMouseDown = (pos: Vec2d): void => {\n    if (isRunning()) {\n      return;\n    }\n\n    if (pos.equals(start)) {\n      return setMoving(MovingState.Start);\n    }\n\n    if (pos.equals(target)) {\n      return setMoving(MovingState.Target);\n    }\n\n    setIsDrawing(true);\n    setMaze(maze.toggleWall(pos));\n  };\n\n  const handleMouseEnter = (pos: Vec2d): void => {\n    if (moving !== MovingState.None && !maze.isWall(pos)) {\n      return moving === MovingState.Start ? setStart(pos) : setTarget(pos);\n    }\n\n    if (isDrawing && !pos.equals(start) && !pos.equals(target)) {\n      setMaze(maze.toggleWall(pos));\n    }\n  };\n\n  const handleStartClick = async (): Promise<void> => {\n    setIsRunning(true);\n\n    if (!hasCurrentSearch()) {\n      setCurrentSearch(generateSearch());\n      setSolution(getInitialSolution());\n    }\n\n    let next;\n\n    do {\n      // @ts-ignore\n      next = currentSearch.current.next();\n      if (next.value) next.value();\n      if (!isRunning()) return;\n      await sleep(8);\n    } while (!next.done);\n\n    setCurrentSearch(null);\n    setIsRunning(false);\n    setFinishedAt(Date.now);\n  };\n\n  const generateSearch = function* (): Generator<() => void> {\n    const method = searchMethods[searchMethod];\n\n    for (const state of method.start({ maze, start, target })) {\n      yield () => setVisited(new Set([...state.visited]));\n\n      if (state.found) {\n        const solution = getInitialSolution();\n        setSolution(solution);\n\n        for (const pos of method.rewind(state.current)) {\n          yield () => setSolution(new Set([...solution.add(pos.toString())]));\n        }\n\n        return;\n      }\n    }\n  };\n\n  const handleStopClick = (): void => setIsRunning(false);\n\n  const handleClearClick = (): void => {\n    setMaze(getInitialMaze(cols, rows));\n    setStart(getInitialStart(cols, rows));\n    setTarget(getInitialTarget(cols, rows));\n    setVisited(getInitialVisited());\n    setSolution(getInitialSolution());\n    setCurrentSearch(null);\n    setIsRunning(false);\n  };\n\n  const handleGenerateClick = (): void => {\n    handleClearClick();\n\n    const maze = mazeGenerators[mazeGenerator].generate(cols, rows);\n    const start = findEmptySquareInBounds(maze, Vec2d.origin(), new Vec2d(cols / 3, rows));\n    const target = findEmptySquareInBounds(maze, new Vec2d((cols * 2) / 3, 0), new Vec2d(cols, rows));\n\n    setMaze(maze);\n    setStart(start);\n    setTarget(target);\n  };\n\n  const handleMazeGeneratorSelect = (e: any): void => setMazeGenerator(e.target.value);\n  const handleSearchMethodSelect = (e: any): void => setSearchMethod(e.target.value);\n\n  const getSquareClassName = (pos: Vec2d): string => {\n    if (maze.isWall(pos)) {\n      return \"is-wall\";\n    }\n\n    if (start.equals(pos)) {\n      return \"is-start\";\n    }\n\n    if (target.equals(pos)) {\n      return \"is-target\";\n    }\n\n    if (solution.has(pos.toString())) {\n      return \"is-solution\";\n    }\n\n    if (visited.has(pos.toString())) {\n      return \"is-visited\";\n    }\n\n    return \"\";\n  };\n\n  return (\n    <div className={`PathFinder${isRunning() ? \" is-running\" : \"\"}`}>\n      <Controls\n        isRunning={isRunning()}\n        onStartClick={handleStartClick}\n        onStopClick={handleStopClick}\n        onClearClick={handleClearClick}\n        onGenerateClick={handleGenerateClick}\n        selectedMazeGenerator={mazeGenerator}\n        selectedSearchMethod={searchMethod}\n        onMazeGeneratorSelect={handleMazeGeneratorSelect}\n        onSearchMethodSelect={handleSearchMethodSelect}\n      />\n      <MazeComponent\n        numRows={rows}\n        numCols={cols}\n        style={mazeStyle}\n        getSquareClassName={getSquareClassName}\n        onMouseUp={handleMouseUp}\n        onMouseDown={handleMouseDown}\n        onMouseEnter={handleMouseEnter}\n      />\n    </div>\n  );\n};\n\nexport default PathFinder;\n","import PriorityQueue from \"ts-priority-queue\";\nimport { SearchNode, SearchParams, SearchState, rewind } from \"../\";\nimport { getNeighbours } from \"../../maze\";\nimport Vec2d from \"../../utils/Vec2d\";\n\nconst manhattanDistance = (a: Vec2d, b: Vec2d): number => Math.abs(a.x - b.x) + Math.abs(a.y - b.y);\n\nconst start = function* ({ maze, start, target }: SearchParams): Generator<SearchState> {\n  const visited = new Set<string>([start.toString()]);\n\n  const queue = new PriorityQueue<SearchNode>({\n    comparator: (a, b) => manhattanDistance(a.pos, target) - manhattanDistance(b.pos, target),\n    initialValues: [{ pos: start }],\n  });\n\n  while (queue.length > 0) {\n    const node = queue.dequeue();\n\n    yield { current: node, visited, found: node.pos.equals(target) };\n\n    for (const neighbour of getNeighbours(maze, node.pos)) {\n      const hash = neighbour.toString();\n\n      if (!visited.has(hash)) {\n        visited.add(hash);\n        queue.queue({ pos: neighbour, prev: node });\n      }\n    }\n  }\n};\n\nconst greedyBestFirstSearch = { name: \"Greedy best-first search\", start, rewind };\n\nexport default greedyBestFirstSearch;\n","import { SearchNode, SearchParams, SearchState, rewind } from \"../\";\nimport { getNeighbours } from \"../../maze\";\n\nconst dfs = function* (node: SearchNode, visited: Set<string>, params: SearchParams): Generator<SearchState> {\n  yield { current: node, visited, found: node.pos.equals(params.target) };\n\n  for (const neighbour of getNeighbours(params.maze, node.pos)) {\n    const hash = neighbour.toString();\n\n    if (!visited.has(hash)) {\n      visited.add(hash);\n      yield* dfs({ pos: neighbour, prev: node }, visited, params);\n    }\n  }\n};\n\nconst start = function* (params: SearchParams): Generator<SearchState> {\n  yield* dfs({ pos: params.start }, new Set([params.start.toString()]), params);\n};\n\nconst depthFirstSearch = { name: \"Depth-first search\", start, rewind };\n\nexport default depthFirstSearch;\n","import { SearchNode, SearchParams, SearchState } from \"../\";\nimport breadthFirstSearch from \"./breadth-first-search\";\nimport biDirectionalBfs from \"./bidirectional-bfs\";\nimport greedBestFirstSearch from \"./greedy-best-first-search\";\nimport depthFirstSearch from \"./depth-first-search\";\nimport Vec2d from \"../../utils/Vec2d\";\n\ntype SearchMethod = {\n  name: string;\n  start: (params: SearchParams) => Generator<SearchState>;\n  rewind: (node: SearchNode) => Vec2d[];\n};\n\nconst methods: { [key: string]: SearchMethod } = {\n  breadthFirstSearch,\n  biDirectionalBfs,\n  greedBestFirstSearch,\n  depthFirstSearch,\n};\n\nexport default methods;\n","const sleep = async (ms: number): Promise<void> => {\n  await new Promise((r) => setTimeout(r, ms));\n};\n\nexport default sleep;\n","import { FormEvent } from \"react\";\nimport mazeGenerators from \"../maze/generators\";\nimport searchMethods from \"../search/methods\";\n\ntype ControlsProps = {\n  isRunning: boolean;\n  onStartClick: () => void;\n  onStopClick: () => void;\n  onClearClick: () => void;\n  onGenerateClick: () => void;\n  selectedMazeGenerator: string;\n  selectedSearchMethod: string;\n  onMazeGeneratorSelect: (e: FormEvent<HTMLSelectElement>) => void;\n  onSearchMethodSelect: (e: FormEvent<HTMLSelectElement>) => void;\n};\n\nconst Controls = (props: ControlsProps): JSX.Element => (\n  <div className=\"Controls\">\n    <fieldset>\n      <legend>Maze generator</legend>\n      <select onChange={props.onMazeGeneratorSelect} value={props.selectedMazeGenerator}>\n        {Object.entries(mazeGenerators).map(([key, generator]) => (\n          <option key={key} value={key}>\n            {generator.name}\n          </option>\n        ))}\n      </select>\n      <button onClick={props.onGenerateClick} disabled={props.isRunning}>\n        Generate\n      </button>\n      <button onClick={props.onClearClick} disabled={props.isRunning}>\n        Clear\n      </button>\n    </fieldset>\n    <fieldset>\n      <legend>Search method</legend>\n      <select onChange={props.onSearchMethodSelect} value={props.selectedSearchMethod}>\n        {Object.entries(searchMethods).map(([key, method]) => (\n          <option key={key} value={key}>\n            {method.name}\n          </option>\n        ))}\n      </select>\n      <button onClick={props.isRunning ? props.onStopClick : props.onStartClick}>\n        {props.isRunning ? \"Stop\" : \"Start\"}\n      </button>\n    </fieldset>\n  </div>\n);\n\nexport default Controls;\n","import React from \"react\";\nimport Vec2d from \"../utils/Vec2d\";\n\ntype MazeProps = {\n  numRows: number;\n  numCols: number;\n  style: React.CSSProperties;\n  getSquareClassName: (pos: Vec2d) => string;\n  onMouseUp: (pos: Vec2d) => void;\n  onMouseDown: (pos: Vec2d) => void;\n  onMouseEnter: (pos: Vec2d) => void;\n};\n\nconst Maze = (props: MazeProps): JSX.Element => {\n  const squares = [];\n\n  for (let row = 0; row < props.numRows; ++row) {\n    for (let col = 0; col < props.numCols; ++col) {\n      const pos = new Vec2d(col, row);\n\n      squares.push(\n        <div\n          key={pos.toString()}\n          className={props.getSquareClassName(pos)}\n          onMouseUp={() => props.onMouseUp(pos)}\n          onMouseDown={() => props.onMouseDown(pos)}\n          onMouseEnter={() => props.onMouseEnter(pos)}\n        />\n      );\n    }\n  }\n\n  return (\n    <div className=\"Maze\" style={props.style}>\n      {squares}\n    </div>\n  );\n};\n\nexport default Maze;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport PathFinder from \"./Components/PathFinder\";\nimport \"./index.css\";\n\nconst buildPathFinderProps = () => {\n  // @ts-ignore\n  const bodyPadding = parseInt(getComputedStyle(document.body).getPropertyValue(\"padding-left\"));\n  // @ts-ignore\n  const headerHeight = parseInt(getComputedStyle(document.querySelector(\"header\")).getPropertyValue(\"height\"));\n  const squareWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue(\"--square-width\"));\n\n  const cols = Math.floor((window.innerWidth - 2 * bodyPadding) / squareWidth);\n  const rows = Math.max(5, Math.floor((window.innerHeight - 3 * headerHeight) / squareWidth));\n\n  return {\n    mazeSize: { cols, rows },\n    mazeStyle: {\n      gridTemplateColumns: `repeat(${cols}, ${squareWidth}px)`,\n      gridTemplateRows: `repeat(${rows}, ${squareWidth}px)`,\n    },\n  };\n};\n\nReactDOM.render(\n  <React.StrictMode>\n    <PathFinder {...buildPathFinderProps()} />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n"],"sourceRoot":""}