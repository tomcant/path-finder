{"version":3,"sources":["search/methods/bidirectional-bfs.ts","maze/Maze.ts","utils/Vec2d.ts","maze/generators/random.ts","search/index.ts","maze/index.ts","search/methods/utils/Queue.ts","search/methods/breadth-first-search.ts","Components/PathFinder.tsx","search/methods/greedy-best-first-search.ts","search/methods/depth-first-search.ts","search/methods/index.ts","Components/utils/sleep.ts","Components/Controls.tsx","Components/Maze.tsx","index.tsx"],"names":["Direction","nodeHistory","Maze","numCols","numRows","walls","Set","pos","this","isWithinBounds","Error","toString","maze","isWall","delete","add","has","x","y","Vec2d","v","minX","minY","maxX","maxY","Math","floor","random","cols","rows","start","target","row","col","equals","toggleWall","rewind","node","path","prev","unshift","getNeighbours","neighbours","dx","dy","neighbour","push","Queue","items","isEmpty","shift","size","length","bfs","name","visited","queue","dequeue","current","found","hash","enqueue","f","MovingState","biDirBfs","visitedForward","visitedBackward","direction","Forward","Backward","neighbourNode","intersection","filter","n","sort","defaultRewind","reverse","manhattanDistance","a","b","abs","greedyBestFirstSearch","PriorityQueue","comparator","initialValues","dfs","params","methods","breadthFirstSearch","biDirectionalBfs","greedBestFirstSearch","sleep","ms","Promise","r","setTimeout","Controls","props","className","onClick","isRunning","onStopClick","onStartClick","onClearClick","disabled","onGenerateClick","onChange","onMethodSelect","value","selectedSearchMethod","Object","entries","map","key","method","squares","getSquareClassName","onMouseUp","onMouseDown","onMouseEnter","style","getInitialMaze","getInitialStart","getInitialTarget","getInitialVisited","getInitialSolution","PathFinder","mazeSize","mazeStyle","useState","setMaze","setStart","setTarget","setVisited","solution","setSolution","searchMethod","setSearchMethod","None","moving","setMoving","isDrawing","setIsDrawing","Date","now","setStopTime","search","useRef","running","setRunning","handleStartClick","generateSearch","next","done","searchMethods","state","handleClearClick","generateMaze","e","Start","Target","ReactDOM","render","StrictMode","bodyPadding","parseInt","getComputedStyle","document","body","getPropertyValue","headerHeight","querySelector","squareWidth","documentElement","window","innerWidth","innerHeight","gridTemplateColumns","gridTemplateRows","buildPathFinderProps","getElementById"],"mappings":"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","file":"static/js/main.1bd72e03.chunk.js","sourcesContent":["import { SearchMethod, SearchNode, SearchParams, SearchState, rewind as defaultRewind } from \"../\";\nimport { getNeighbours } from \"../../maze\";\nimport Queue from \"./utils/Queue\";\nimport Vec2d from \"../../utils/Vec2d\";\n\nenum Direction {\n  Forward,\n  Backward,\n}\n\ntype BiDirSearchNode = {\n  node: SearchNode;\n  direction: Direction;\n};\n\nlet nodeHistory: BiDirSearchNode[];\n\nconst start = function* ({ maze, start, target }: SearchParams): Generator<SearchState> {\n  nodeHistory = [];\n\n  const visitedForward = new Set<string>([start.toString()]);\n  const visitedBackward = new Set<string>([target.toString()]);\n\n  const queue = new Queue<BiDirSearchNode>([\n    {\n      node: { pos: start },\n      direction: Direction.Forward,\n    },\n    {\n      node: { pos: target },\n      direction: Direction.Backward,\n    },\n  ]);\n\n  while (!queue.isEmpty()) {\n    const { node, direction } = queue.dequeue();\n\n    const found =\n      (direction === Direction.Forward && visitedBackward.has(node.pos.toString())) ||\n      (direction === Direction.Backward && visitedForward.has(node.pos.toString()));\n\n    yield { current: node, visited: new Set([...visitedForward, ...visitedBackward]), found };\n\n    for (const neighbour of getNeighbours(maze, node.pos)) {\n      const hash = neighbour.toString();\n      let enqueue = false;\n\n      if (direction === Direction.Forward) {\n        if (!visitedForward.has(hash)) {\n          visitedForward.add(hash);\n          enqueue = true;\n        }\n      } else if (!visitedBackward.has(hash)) {\n        visitedBackward.add(hash);\n        enqueue = true;\n      }\n\n      if (enqueue) {\n        const neighbourNode = {\n          node: {\n            pos: neighbour,\n            prev: node,\n          },\n          direction,\n        };\n\n        nodeHistory.push(neighbourNode);\n        queue.enqueue(neighbourNode);\n      }\n    }\n  }\n};\n\nconst rewind = (node: SearchNode): Vec2d[] => {\n  const intersection = nodeHistory\n    .filter(({ node: n }) => node.pos.equals(n.pos))\n    .sort(({ direction }) => (direction === Direction.Forward ? -1 : 1));\n\n  return [...defaultRewind(intersection[0].node), ...defaultRewind(intersection[1].node).reverse()];\n};\n\nconst biDirBfs: SearchMethod = { name: \"Bidirectional BFS\", start, rewind };\n\nexport default biDirBfs;\n","import Vec2d from \"../utils/Vec2d\";\n\nexport default class Maze {\n  private walls = new Set<string>();\n\n  public constructor(readonly numCols: number, readonly numRows: number) {}\n\n  public toggleWall(pos: Vec2d): Maze {\n    if (!this.isWithinBounds(pos)) {\n      throw new Error(`Out of bounds: ${pos.toString()}`);\n    }\n\n    const maze = new Maze(this.numCols, this.numRows);\n    maze.walls = new Set([...this.walls]);\n\n    if (maze.isWall(pos)) {\n      maze.walls.delete(pos.toString());\n    } else {\n      maze.walls.add(pos.toString());\n    }\n\n    return maze;\n  }\n\n  public isWall(pos: Vec2d): boolean {\n    return this.walls.has(pos.toString());\n  }\n\n  public isWithinBounds(pos: Vec2d): boolean {\n    return pos.x >= 0 && pos.y >= 0 && pos.x < this.numCols && pos.y < this.numRows;\n  }\n}\n","export default class Vec2d {\n  constructor(readonly x: number, readonly y: number) {}\n\n  public add(v: Vec2d): Vec2d {\n    return new Vec2d(this.x + v.x, this.y + v.y);\n  }\n\n  public equals(v: Vec2d): boolean {\n    return this.x === v.x && this.y === v.y;\n  }\n\n  public toString(): string {\n    return `(${this.x}, ${this.y})`;\n  }\n\n  public static random(minX: number, minY: number, maxX: number, maxY: number): Vec2d {\n    return new Vec2d(\n      Math.floor(minX + Math.random() * (maxX - minX)),\n      Math.floor(minY + Math.random() * (maxY - minY))\n    );\n  }\n}\n","import Maze from \"../Maze\";\nimport Vec2d from \"../../utils/Vec2d\";\n\nconst random = (cols: number, rows: number) => {\n  const start = Vec2d.random(0, 0, cols / 3, rows / 3);\n  const target = Vec2d.random((cols * 2) / 3, (rows * 2) / 3, cols, rows);\n\n  let maze = new Maze(cols, rows);\n\n  for (let row = 0; row < rows; ++row) {\n    for (let col = 0; col < cols; ++col) {\n      const pos = new Vec2d(col, row);\n\n      if (start.equals(pos) || target.equals(pos)) {\n        continue;\n      }\n\n      if (Math.random() < 0.25) {\n        maze = maze.toggleWall(pos);\n      }\n    }\n  }\n\n  return { maze, start, target };\n};\n\nexport default random;\n","import Maze from \"../maze/Maze\";\nimport Vec2d from \"../utils/Vec2d\";\n\nexport type SearchParams = {\n  maze: Maze;\n  start: Vec2d;\n  target: Vec2d;\n};\n\nexport type SearchNode = {\n  pos: Vec2d;\n  prev?: SearchNode;\n};\n\nexport type SearchState = {\n  current: SearchNode;\n  visited: Set<string>;\n  found: boolean;\n};\n\nexport type SearchMethod = {\n  name: string;\n  start: (params: SearchParams) => Generator<SearchState>;\n  rewind: (node: SearchNode) => Vec2d[];\n};\n\nexport const rewind = (node: SearchNode): Vec2d[] => {\n  const path = [];\n\n  while (node.prev) {\n    path.unshift(node.pos);\n    node = node.prev;\n  }\n\n  return path;\n};\n","import Maze from \"./Maze\";\nimport Vec2d from \"../utils/Vec2d\";\n\nexport const getNeighbours = (maze: Maze, pos: Vec2d): Vec2d[] => {\n  const neighbours = [];\n\n  const dirs = [\n    { dx: 1, dy: 0 },\n    { dx: 0, dy: 1 },\n    { dx: -1, dy: 0 },\n    { dx: 0, dy: -1 },\n  ];\n\n  for (const { dx, dy } of dirs) {\n    const neighbour = pos.add(new Vec2d(dx, dy));\n\n    if (maze.isWithinBounds(neighbour) && !maze.isWall(neighbour)) {\n      neighbours.push(neighbour);\n    }\n  }\n\n  return neighbours;\n};\n","export default class Queue<T> {\n  constructor(private items: T[] = []) {}\n\n  public enqueue(...items: T[]): void {\n    this.items.push(...items);\n  }\n\n  public dequeue(): T {\n    if (this.isEmpty()) {\n      throw new Error(\"Cannot dequeue empty queue\");\n    }\n\n    return this.items.shift() as T;\n  }\n\n  public isEmpty(): boolean {\n    return this.size === 0;\n  }\n\n  public get size(): number {\n    return this.items.length;\n  }\n}\n","import { SearchMethod, SearchNode, SearchParams, SearchState, rewind } from \"../\";\nimport { getNeighbours } from \"../../maze\";\nimport Queue from \"./utils/Queue\";\n\nconst start = function* ({ maze, start, target }: SearchParams): Generator<SearchState> {\n  const visited = new Set<string>([start.toString()]);\n  const queue = new Queue<SearchNode>([{ pos: start }]);\n\n  while (!queue.isEmpty()) {\n    const node = queue.dequeue();\n\n    yield { current: node, visited, found: node.pos.equals(target) };\n\n    for (const neighbour of getNeighbours(maze, node.pos)) {\n      const hash = neighbour.toString();\n\n      if (!visited.has(hash)) {\n        visited.add(hash);\n        queue.enqueue({ pos: neighbour, prev: node });\n      }\n    }\n  }\n};\n\nconst bfs: SearchMethod = { name: \"Breadth-first search\", start, rewind };\n\nexport default bfs;\n","import React, { useRef, useState } from \"react\";\nimport Maze from \"../maze/Maze\";\nimport generateMaze from \"../maze/generators/random\";\nimport searchMethods from \"../search/methods\";\nimport Vec2d from \"../utils/Vec2d\";\nimport sleep from \"./utils/sleep\";\nimport Controls from \"./Controls\";\nimport MazeComponent from \"./Maze\";\n\ntype PathFinderProps = {\n  mazeSize: {\n    cols: number;\n    rows: number;\n  };\n  mazeStyle: React.CSSProperties;\n};\n\nenum MovingState {\n  None,\n  Start,\n  Target,\n}\n\nconst getInitialMaze = (cols: number, rows: number) => new Maze(cols, rows);\nconst getInitialStart = (cols: number, rows: number) => new Vec2d(Math.floor(cols / 4) - 1, Math.floor(rows / 2) - 1);\nconst getInitialTarget = (cols: number, rows: number) => new Vec2d(cols - Math.floor(cols / 4), Math.floor(rows / 2) - 1);\nconst getInitialVisited = () => new Set<string>();\nconst getInitialSolution = () => new Set<string>();\n\nconst PathFinder = ({ mazeSize: { cols, rows }, mazeStyle }: PathFinderProps): JSX.Element => {\n  const [maze, setMaze] = useState(getInitialMaze(cols, rows));\n  const [start, setStart] = useState(getInitialStart(cols, rows));\n  const [target, setTarget] = useState(getInitialTarget(cols, rows));\n  const [visited, setVisited] = useState(getInitialVisited());\n  const [solution, setSolution] = useState(getInitialSolution());\n\n  const [searchMethod, setSearchMethod] = useState(\"breadth-first-search\");\n  const [moving, setMoving] = useState(MovingState.None);\n  const [isDrawing, setIsDrawing] = useState(false);\n  const [, setStopTime] = useState(Date.now);\n\n  const search = useRef<Generator | null>(null);\n\n  const running = useRef(false);\n  const isRunning = (): boolean => running.current;\n  const setRunning = (r: boolean): void => {\n    running.current = r;\n    if (!r) setStopTime(Date.now);\n  };\n\n  const handleMouseUp = (): void => {\n    setMoving(MovingState.None);\n    setIsDrawing(false);\n  };\n\n  const handleMouseDown = (pos: Vec2d): void => {\n    if (isRunning()) {\n      return;\n    }\n\n    if (pos.equals(start)) {\n      return setMoving(MovingState.Start);\n    }\n\n    if (pos.equals(target)) {\n      return setMoving(MovingState.Target);\n    }\n\n    setIsDrawing(true);\n    setMaze(maze.toggleWall(pos));\n  };\n\n  const handleMouseEnter = (pos: Vec2d): void => {\n    if (moving !== MovingState.None && !maze.isWall(pos)) {\n      return moving === MovingState.Start ? setStart(pos) : setTarget(pos);\n    }\n\n    if (isDrawing && !pos.equals(start) && !pos.equals(target)) {\n      setMaze(maze.toggleWall(pos));\n    }\n  };\n\n  const handleStartClick = async (): Promise<void> => {\n    setRunning(true);\n\n    if (!search.current) {\n      search.current = generateSearch();\n      setSolution(getInitialSolution());\n    }\n\n    let next;\n\n    do {\n      next = search.current.next();\n      if (next.value) next.value();\n      if (!isRunning()) return;\n      await sleep(5);\n    } while (!next.done);\n\n    search.current = null;\n    setRunning(false);\n  };\n\n  const generateSearch = function* (): Generator<() => void> {\n    // @ts-ignore\n    const method = searchMethods[searchMethod];\n\n    for (const state of method.start({ maze, start, target })) {\n      yield () => setVisited(new Set([...state.visited]));\n\n      if (state.found) {\n        const solution = getInitialSolution();\n        setSolution(solution);\n\n        for (const pos of method.rewind(state.current)) {\n          yield () => setSolution(new Set([...solution.add(pos.toString())]));\n        }\n\n        return;\n      }\n    }\n  };\n\n  const handleStopClick = (): void => {\n    setRunning(false);\n  };\n\n  const handleClearClick = (): void => {\n    setMaze(getInitialMaze(cols, rows));\n    setStart(getInitialStart(cols, rows));\n    setTarget(getInitialTarget(cols, rows));\n    setVisited(getInitialVisited());\n    setSolution(getInitialSolution());\n    setRunning(false);\n    search.current = null;\n  };\n\n  const handleGenerateClick = (): void => {\n    handleClearClick();\n\n    const { maze, start, target } = generateMaze(cols, rows);\n\n    setMaze(maze);\n    setStart(start);\n    setTarget(target);\n  };\n\n  const handleMethodSelect = (e: any): void => {\n    setSearchMethod(e.target.value);\n  };\n\n  const getSquareClassName = (pos: Vec2d): string => {\n    if (maze.isWall(pos)) {\n      return \"is-wall\";\n    }\n\n    if (start.equals(pos)) {\n      return \"is-start\";\n    }\n\n    if (target.equals(pos)) {\n      return \"is-target\";\n    }\n\n    if (solution.has(pos.toString())) {\n      return \"is-solution\";\n    }\n\n    if (visited.has(pos.toString())) {\n      return \"is-visited\";\n    }\n\n    return \"\";\n  };\n\n  return (\n    <div className={`PathFinder${isRunning() ? \" is-running\" : \"\"}`}>\n      <Controls\n        isRunning={isRunning()}\n        onStartClick={handleStartClick}\n        onStopClick={handleStopClick}\n        onClearClick={handleClearClick}\n        onGenerateClick={handleGenerateClick}\n        onMethodSelect={handleMethodSelect}\n        selectedSearchMethod={searchMethod}\n      />\n      <MazeComponent\n        numRows={rows}\n        numCols={cols}\n        style={mazeStyle}\n        getSquareClassName={getSquareClassName}\n        onMouseUp={handleMouseUp}\n        onMouseDown={handleMouseDown}\n        onMouseEnter={handleMouseEnter}\n      />\n    </div>\n  );\n};\n\nexport default PathFinder;\n","import PriorityQueue from \"ts-priority-queue\";\nimport { SearchMethod, SearchNode, SearchParams, SearchState, rewind } from \"../\";\nimport { getNeighbours } from \"../../maze\";\nimport Vec2d from \"../../utils/Vec2d\";\n\nconst manhattanDistance = (a: Vec2d, b: Vec2d): number => Math.abs(a.x - b.x) + Math.abs(a.y - b.y);\n\nconst start = function* ({ maze, start, target }: SearchParams): Generator<SearchState> {\n  const visited = new Set<string>([start.toString()]);\n\n  const queue = new PriorityQueue<SearchNode>({\n    comparator: (a, b) => manhattanDistance(a.pos, target) - manhattanDistance(b.pos, target),\n    initialValues: [{ pos: start }],\n  });\n\n  while (queue.length > 0) {\n    const node = queue.dequeue();\n\n    yield { current: node, visited, found: node.pos.equals(target) };\n\n    for (const neighbour of getNeighbours(maze, node.pos)) {\n      const hash = neighbour.toString();\n\n      if (!visited.has(hash)) {\n        visited.add(hash);\n        queue.queue({ pos: neighbour, prev: node });\n      }\n    }\n  }\n};\n\nconst greedyBestFirstSearch: SearchMethod = { name: \"Greedy best-first search\", start, rewind };\n\nexport default greedyBestFirstSearch;\n","import { SearchMethod, SearchNode, SearchParams, SearchState, rewind } from \"../\";\nimport { getNeighbours } from \"../../maze\";\n\nconst dfs = function* (node: SearchNode, visited: Set<string>, params: SearchParams): Generator<SearchState> {\n  yield { current: node, visited, found: node.pos.equals(params.target) };\n\n  for (const neighbour of getNeighbours(params.maze, node.pos)) {\n    const hash = neighbour.toString();\n\n    if (!visited.has(hash)) {\n      visited.add(hash);\n      yield* dfs({ pos: neighbour, prev: node }, visited, params);\n    }\n  }\n};\n\nconst start = function* (params: SearchParams): Generator<SearchState> {\n  yield* dfs({ pos: params.start }, new Set([params.start.toString()]), params);\n};\n\nconst depthFirstSearch: SearchMethod = { name: \"Depth-first search\", start, rewind };\n\nexport default depthFirstSearch;\n","import breadthFirstSearch from \"./breadth-first-search\";\nimport biDirectionalBfs from \"./bidirectional-bfs\";\nimport greedBestFirstSearch from \"./greedy-best-first-search\";\nimport depthFirstSearch from \"./depth-first-search\";\n\nconst methods = {\n  \"breadth-first-search\": breadthFirstSearch,\n  \"bidirectional-bfs\": biDirectionalBfs,\n  \"greedy-best-first-search\": greedBestFirstSearch,\n  \"depth-first-search\": depthFirstSearch,\n};\n\nexport default methods;\n","const sleep = async (ms: number): Promise<void> => {\n  await new Promise((r) => setTimeout(r, ms));\n};\n\nexport default sleep;\n","import { FormEvent } from \"react\";\nimport methods from \"../search/methods\";\n\ntype ControlsProps = {\n  isRunning: boolean;\n  onStartClick: () => void;\n  onStopClick: () => void;\n  onClearClick: () => void;\n  onGenerateClick: () => void;\n  onMethodSelect: (e: FormEvent<HTMLSelectElement>) => void;\n  selectedSearchMethod: string;\n};\n\nconst Controls = (props: ControlsProps): JSX.Element => (\n  <div className=\"Controls\">\n    <button onClick={props.isRunning ? props.onStopClick : props.onStartClick}>\n      {props.isRunning ? \"Stop\" : \"Start\"}\n    </button>\n    <button onClick={props.onClearClick} disabled={props.isRunning}>\n      Clear\n    </button>\n    <button onClick={props.onGenerateClick} disabled={props.isRunning}>\n      Generate\n    </button>\n    <select onChange={props.onMethodSelect} value={props.selectedSearchMethod}>\n      {Object.entries(methods).map(([key, method]) => (\n        <option key={key} value={key}>\n          {method.name}\n        </option>\n      ))}\n    </select>\n  </div>\n);\n\nexport default Controls;\n","import React from \"react\";\nimport Vec2d from \"../utils/Vec2d\";\n\ntype MazeProps = {\n  numRows: number;\n  numCols: number;\n  style: React.CSSProperties;\n  getSquareClassName: (pos: Vec2d) => string;\n  onMouseUp: (pos: Vec2d) => void;\n  onMouseDown: (pos: Vec2d) => void;\n  onMouseEnter: (pos: Vec2d) => void;\n};\n\nconst Maze = (props: MazeProps): JSX.Element => {\n  const squares = [];\n\n  for (let row = 0; row < props.numRows; ++row) {\n    for (let col = 0; col < props.numCols; ++col) {\n      const pos = new Vec2d(col, row);\n\n      squares.push(\n        <div\n          key={pos.toString()}\n          className={props.getSquareClassName(pos)}\n          onMouseUp={() => props.onMouseUp(pos)}\n          onMouseDown={() => props.onMouseDown(pos)}\n          onMouseEnter={() => props.onMouseEnter(pos)}\n        />\n      );\n    }\n  }\n\n  return (\n    <div className=\"Maze\" style={props.style}>\n      {squares}\n    </div>\n  );\n};\n\nexport default Maze;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport PathFinder from \"./Components/PathFinder\";\nimport \"./index.css\";\n\nconst buildPathFinderProps = () => {\n  // @ts-ignore\n  const bodyPadding = parseInt(getComputedStyle(document.body).getPropertyValue(\"padding-left\"));\n  // @ts-ignore\n  const headerHeight = parseInt(getComputedStyle(document.querySelector(\"header\")).getPropertyValue(\"height\"));\n  const squareWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue(\"--square-width\"));\n\n  const cols = Math.floor((window.innerWidth - 2 * bodyPadding) / squareWidth);\n  const rows = Math.floor((window.innerHeight - 2 * headerHeight - bodyPadding) / squareWidth);\n\n  return {\n    mazeSize: { cols, rows },\n    mazeStyle: {\n      gridTemplateColumns: `repeat(${cols}, ${squareWidth}px)`,\n      gridTemplateRows: `repeat(${rows}, ${squareWidth}px)`,\n    },\n  };\n};\n\nReactDOM.render(\n  <React.StrictMode>\n    <PathFinder {...buildPathFinderProps()} />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n"],"sourceRoot":""}