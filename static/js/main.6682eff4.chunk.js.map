{"version":3,"sources":["maze/generators/depth-first-search.ts","maze/generators/recursive-division.ts","search/methods/bidirectional-bfs.ts","utils/random.ts","utils/Vec2d.ts","maze/index.ts","maze/Maze.ts","maze/generators/prims.ts","maze/generators/binary-tree.ts","maze/generators/index.ts","maze/generators/random.ts","search/index.ts","search/methods/utils/Queue.ts","search/methods/breadth-first-search.ts","Components/PathFinder.tsx","search/methods/greedy-best-first-search.ts","search/methods/depth-first-search.ts","search/methods/index.ts","Components/utils/sleep.ts","Components/Controls.tsx","Components/Maze.tsx","index.tsx"],"names":["maze","Direction","nodeHistory","random","max","Math","floor","randomEven","ceil","randomElement","elements","length","shuffle","arr","currIdx","randIdx","Vec2d","x","y","v","this","from","to","DIRECTIONS","dx","dy","getAdjacentMazePositions","pos","dist","map","add","getAdjacentPositions","filter","isWithinBounds","getAdjacentWallPositions","isWall","getAdjacentPathPositions","findEmptySquareInBounds","square","Maze","numCols","numRows","walls","Set","weights","Map","isWeight","has","toString","toggleWalls","positions","clone","Error","delete","get","weight","set","empty","row","col","push","prims","name","generate","cols","rows","full","frontier","origin","some","cell","toggleWall","adjPath","randomPath","binaryTree","wallLeftOrUp","start","dfs","visited","neighbour","hash","f","depthFirstSearch","divide","width","height","xy","vertical","gap","wallFrom","wallTo","direction","equals","generators","recursiveDivision","rewind","node","path","prev","unshift","Queue","items","isEmpty","shift","size","breadthFirstSearch","search","target","queue","dequeue","current","found","enqueue","MovingState","biDirBfs","Forward","Backward","visitedForward","visitedBackward","neighbourNode","intersection","n","sort","defaultRewind","reverse","PriorityQueue","comparator","a","b","manhattanDistance","initialValues","abs","greedyBestFirstSearch","params","methods","biDirectionalBfs","greedBestFirstSearch","sleep","ms","Promise","r","setTimeout","Controls","props","className","onChange","onMazeGeneratorSelect","value","selectedMazeGenerator","Object","entries","mazeGenerators","key","generator","onClick","onGenerateClick","disabled","isSearching","isGenerating","onClearClick","onSearchMethodSelect","selectedSearchMethod","searchMethods","method","onStopClick","onStartClick","squares","getSquareClassName","onMouseUp","onMouseDown","onMouseEnter","style","getInitialMaze","getInitialStart","getInitialTarget","getInitialVisited","getInitialSolution","PathFinder","mazeSize","mazeStyle","useState","setMaze","setStart","setTarget","setVisited","solution","setSolution","Date","now","setFinishedAt","None","moving","setMoving","isDrawing","setIsDrawing","setIsGenerating","mazeGenerator","setMazeGenerator","searchMethod","setSearchMethod","currentSearch","useRef","setCurrentSearch","s","_isSearching","setIsSearching","handleStartClick","generateSearch","next","done","state","handleClearClick","handleGenerateClick","outOfBounds","finalMaze","e","Start","Target","ReactDOM","render","StrictMode","bodyPadding","parseInt","getComputedStyle","document","body","getPropertyValue","headerHeight","querySelector","squareWidth","documentElement","window","innerWidth","innerHeight","gridTemplateColumns","gridTemplateRows","buildPathFinderProps","getElementById"],"mappings":"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","file":"static/js/main.6682eff4.chunk.js","sourcesContent":["import Maze from \"../Maze\";\nimport Vec2d from \"../../utils/Vec2d\";\nimport { shuffle } from \"../../utils/random\";\nimport { getAdjacentWallPositions } from \"../\";\n\nlet maze: Maze;\n\nconst generate = function* (cols: number, rows: number): Generator<Maze> {\n  const start = Vec2d.random(Vec2d.origin(), new Vec2d(cols, rows));\n  maze = Maze.full(cols, rows).toggleWall(start);\n  yield* dfs(start, new Set([start.toString()]));\n};\n\nconst dfs = function* (pos: Vec2d, visited: Set<string>): Generator<Maze> {\n  for (const neighbour of shuffle(getAdjacentWallPositions(maze, pos, 2))) {\n    const hash = neighbour.toString();\n\n    if (!visited.has(hash)) {\n      yield (maze = maze.toggleWalls([neighbour, new Vec2d((pos.x + neighbour.x) / 2, (pos.y + neighbour.y) / 2)]));\n      yield* dfs(neighbour, visited.add(hash));\n    }\n  }\n};\n\nconst depthFirstSearch = { name: \"Depth-first search\", generate };\n\nexport default depthFirstSearch;\n","import Maze from \"../Maze\";\nimport Vec2d from \"../../utils/Vec2d\";\nimport { randomEven } from \"../../utils/random\";\n\nlet maze: Maze;\n\nconst generate = function* (cols: number, rows: number): Generator<Maze> {\n  maze = Maze.empty(cols, rows);\n\n  for (let col = 0; col < cols; ++col) {\n    yield (maze = maze.toggleWalls([new Vec2d(col, 0), new Vec2d(cols - col - 1, rows - 1)]));\n  }\n\n  for (let row = 1; row < rows - 1; ++row) {\n    yield (maze = maze.toggleWalls([new Vec2d(0, row), new Vec2d(cols - 1, rows - row - 1)]));\n  }\n\n  yield* divide(new Vec2d(1, 1), new Vec2d(cols - 2, rows - 2));\n};\n\nconst divide = function* (from: Vec2d, to: Vec2d): Generator<Maze> {\n  const width = to.x - from.x + 1;\n  const height = to.y - from.y + 1;\n\n  if (width < 3 || height < 3) {\n    return;\n  }\n\n  const vertical = width > height;\n  const xy = 1 + (vertical ? from.x + randomEven(width - 2) : from.y + randomEven(height - 2));\n  const gap = vertical ? new Vec2d(xy, from.y + randomEven(height)) : new Vec2d(from.x + randomEven(width), xy);\n  const wallFrom = vertical ? new Vec2d(xy, from.y) : new Vec2d(from.x, xy);\n  const wallTo = vertical ? new Vec2d(xy, to.y + 1) : new Vec2d(to.x + 1, xy);\n  const direction = vertical ? new Vec2d(0, 1) : new Vec2d(1, 0);\n\n  let pos = wallFrom;\n  while (!pos.equals(wallTo)) {\n    if (!pos.equals(gap)) {\n      yield (maze = maze.toggleWall(pos));\n    }\n    pos = pos.add(direction);\n  }\n\n  if (vertical) {\n    yield* divide(from, new Vec2d(wallTo.x - 1, to.y));\n    yield* divide(new Vec2d(wallTo.x + 1, from.y), to);\n  } else {\n    yield* divide(from, new Vec2d(to.x, wallTo.y - 1));\n    yield* divide(new Vec2d(from.x, wallTo.y + 1), to);\n  }\n};\n\nconst recursiveDivision = { name: \"Recursive division\", generate };\n\nexport default recursiveDivision;\n","import { SearchNode, SearchParams, SearchState, rewind as defaultRewind } from \"../\";\nimport { getAdjacentPathPositions } from \"../../maze\";\nimport Queue from \"./utils/Queue\";\nimport Vec2d from \"../../utils/Vec2d\";\n\nenum Direction {\n  Forward,\n  Backward,\n}\n\ntype BiDirSearchNode = {\n  node: SearchNode;\n  direction: Direction;\n};\n\nlet nodeHistory: BiDirSearchNode[];\n\nconst search = function* ({ maze, start, target }: SearchParams): Generator<SearchState> {\n  nodeHistory = [];\n\n  const queue = new Queue<BiDirSearchNode>([\n    {\n      node: { pos: start },\n      direction: Direction.Forward,\n    },\n    {\n      node: { pos: target },\n      direction: Direction.Backward,\n    },\n  ]);\n  const visitedForward = new Set<string>();\n  const visitedBackward = new Set<string>();\n\n  while (!queue.isEmpty()) {\n    const { node, direction } = queue.dequeue();\n    const hash = node.pos.toString();\n    let found;\n\n    switch (direction) {\n      case Direction.Forward:\n        if (visitedForward.has(hash)) continue;\n        found = visitedBackward.has(hash);\n        visitedForward.add(hash);\n        break;\n\n      case Direction.Backward:\n        if (visitedBackward.has(hash)) continue;\n        found = visitedForward.has(hash);\n        visitedBackward.add(hash);\n        break;\n    }\n\n    yield { current: node, visited: new Set([...visitedForward, ...visitedBackward]), found };\n\n    for (const neighbour of getAdjacentPathPositions(maze, node.pos)) {\n      const neighbourNode = {\n        node: {\n          pos: neighbour,\n          prev: node,\n        },\n        direction,\n      };\n\n      nodeHistory.push(neighbourNode);\n      queue.enqueue(neighbourNode);\n    }\n  }\n};\n\nconst rewind = (node: SearchNode): Vec2d[] => {\n  const intersection = nodeHistory\n    .filter(({ node: n }) => node.pos.equals(n.pos))\n    .sort(({ direction }) => (direction === Direction.Forward ? -1 : 1));\n\n  return [...defaultRewind(intersection[0].node), ...defaultRewind(intersection[1].node).reverse()];\n};\n\nconst biDirBfs = { name: \"Bidirectional BFS\", search, rewind };\n\nexport default biDirBfs;\n","export const random = (max: number): number => Math.floor(Math.random() * max);\n\nexport const randomEven = (max: number): number => 2 * random(Math.ceil(max / 2));\n\nexport const randomElement = <T>(elements: T[]): T => elements[random(elements.length)];\n\nexport const shuffle = <T>(arr: T[]): T[] => {\n  let currIdx = arr.length;\n\n  while (currIdx > 0) {\n    const randIdx = random(currIdx--);\n    [arr[currIdx], arr[randIdx]] = [arr[randIdx], arr[currIdx]];\n  }\n\n  return arr;\n};\n","import { random } from \"./random\";\n\nexport default class Vec2d {\n  constructor(readonly x: number, readonly y: number) {}\n\n  public add(v: Vec2d): Vec2d {\n    return new Vec2d(this.x + v.x, this.y + v.y);\n  }\n\n  public equals(v: Vec2d): boolean {\n    return this.x === v.x && this.y === v.y;\n  }\n\n  public toString(): string {\n    return `(${this.x}, ${this.y})`;\n  }\n\n  public static origin(): Vec2d {\n    return new Vec2d(0, 0);\n  }\n\n  public static random(from: Vec2d, to: Vec2d): Vec2d {\n    return new Vec2d(from.x + random(to.x - from.x), from.y + random(to.y - from.y));\n  }\n}\n","import Maze from \"./Maze\";\nimport Vec2d from \"../utils/Vec2d\";\n\nconst DIRECTIONS = [\n  { dx: 1, dy: 0 },\n  { dx: 0, dy: 1 },\n  { dx: -1, dy: 0 },\n  { dx: 0, dy: -1 },\n];\n\nconst getAdjacentPositions = (pos: Vec2d, dist: number): Vec2d[] =>\n  DIRECTIONS.map(({ dx, dy }) => pos.add(new Vec2d(dx * dist, dy * dist)));\n\nconst getAdjacentMazePositions = (maze: Maze, pos: Vec2d, dist: number): Vec2d[] =>\n  getAdjacentPositions(pos, dist).filter((pos) => maze.isWithinBounds(pos));\n\nexport const getAdjacentWallPositions = (maze: Maze, pos: Vec2d, dist: number = 1): Vec2d[] =>\n  getAdjacentMazePositions(maze, pos, dist).filter((pos) => maze.isWall(pos));\n\nexport const getAdjacentPathPositions = (maze: Maze, pos: Vec2d, dist: number = 1): Vec2d[] =>\n  getAdjacentMazePositions(maze, pos, dist).filter((pos) => !maze.isWall(pos));\n\nexport const findEmptySquareInBounds = (maze: Maze, from: Vec2d, to: Vec2d): Vec2d => {\n  let square;\n\n  do square = Vec2d.random(from, to);\n  while (maze.isWall(square));\n\n  return square;\n};\n","import Vec2d from \"../utils/Vec2d\";\n\nexport default class Maze {\n  private walls = new Set<string>();\n  private weights = new Map<string, number>();\n\n  private constructor(readonly numCols: number, readonly numRows: number) {}\n\n  public static empty(numCols: number, numRows: number): Maze {\n    return new Maze(numCols, numRows);\n  }\n\n  public static full(numCols: number, numRows: number): Maze {\n    const walls = [];\n\n    for (let row = 0; row < numRows; ++row) {\n      for (let col = 0; col < numCols; ++col) {\n        walls.push(new Vec2d(col, row));\n      }\n    }\n\n    return Maze.empty(numCols, numRows).toggleWalls(walls);\n  }\n\n  public isEmpty(pos: Vec2d): boolean {\n    return !this.isWall(pos) && !this.isWeight(pos);\n  }\n\n  public isWall(pos: Vec2d): boolean {\n    return this.walls.has(pos.toString());\n  }\n\n  public toggleWall(pos: Vec2d): Maze {\n    return this.toggleWalls([pos]);\n  }\n\n  public toggleWalls(positions: Vec2d[]): Maze {\n    const maze = this.clone();\n\n    for (const pos of positions) {\n      if (!this.isWithinBounds(pos)) {\n        throw new Error(`Out of bounds: ${pos.toString()}`);\n      }\n\n      if (maze.isWall(pos)) {\n        maze.walls.delete(pos.toString());\n      } else {\n        maze.walls.add(pos.toString());\n      }\n    }\n\n    return maze;\n  }\n\n  public isWeight(pos: Vec2d): boolean {\n    return this.weights.has(pos.toString());\n  }\n\n  public getWeight(pos: Vec2d): number {\n    return this.weights.get(pos.toString()) || 1;\n  }\n\n  public setWeight(pos: Vec2d, weight: number): Maze {\n    const maze = this.clone();\n    maze.walls.delete(pos.toString());\n\n    if (weight > 1) {\n      maze.weights.set(pos.toString(), weight);\n    } else {\n      maze.weights.delete(pos.toString());\n    }\n\n    return maze;\n  }\n\n  public isWithinBounds(pos: Vec2d): boolean {\n    return pos.x >= 0 && pos.y >= 0 && pos.x < this.numCols && pos.y < this.numRows;\n  }\n\n  private clone(): Maze {\n    const maze = Maze.empty(this.numCols, this.numRows);\n\n    maze.walls = new Set([...this.walls]);\n    maze.weights = new Map([...this.weights]);\n\n    return maze;\n  }\n}\n","import Maze from \"../Maze\";\nimport Vec2d from \"../../utils/Vec2d\";\nimport { randomElement } from \"../../utils/random\";\nimport { getAdjacentWallPositions, getAdjacentPathPositions } from \"../\";\n\nconst generate = function* (cols: number, rows: number): Generator<Maze> {\n  let maze = Maze.full(cols, rows);\n  const frontier = [Vec2d.random(Vec2d.origin(), new Vec2d(cols, rows))];\n\n  // eslint-disable-next-line no-loop-func\n  while (frontier.some((pos) => maze.isWall(pos))) {\n    // eslint-disable-next-line no-loop-func\n    const cell = randomElement(frontier.filter((pos) => maze.isWall(pos)));\n    maze = maze.toggleWall(cell);\n\n    const adjPath = getAdjacentPathPositions(maze, cell, 2);\n    if (adjPath.length > 0) {\n      const randomPath = randomElement(adjPath);\n      yield (maze = maze.toggleWall(new Vec2d((cell.x + randomPath.x) / 2, (cell.y + randomPath.y) / 2)));\n    }\n\n    frontier.push(...getAdjacentWallPositions(maze, cell, 2));\n  }\n};\n\nconst prims = { name: \"Prims\", generate };\n\nexport default prims;\n","import Maze from \"../Maze\";\nimport Vec2d from \"../../utils/Vec2d\";\nimport { random } from \"../../utils/random\";\n\nconst generate = function* (cols: number, rows: number): Generator<Maze> {\n  let maze = Maze.empty(cols, rows);\n\n  for (let row = 2; row < rows; row += 2) {\n    for (let col = 2; col < cols; col += 2) {\n      const wallLeftOrUp = [new Vec2d(col - 1, row), new Vec2d(col, row - 1)];\n      yield (maze = maze.toggleWalls([wallLeftOrUp[random(2)], new Vec2d(col - 1, row - 1)]));\n    }\n  }\n};\n\nconst binaryTree = { name: \"Binary tree\", generate };\n\nexport default binaryTree;\n","import Maze from \"../Maze\";\nimport prims from \"./prims\";\nimport binaryTree from \"./binary-tree\";\nimport depthFirstSearch from \"./depth-first-search\";\nimport recursiveDivision from \"./recursive-division\";\nimport random from \"./random\";\n\ntype MazeGenerator = {\n  name: string;\n  generate: (cols: number, rows: number) => Generator<Maze>;\n};\n\nconst generators: { [key: string]: MazeGenerator } = { prims, binaryTree, recursiveDivision, depthFirstSearch, random };\n\nexport default generators;\n","import Maze from \"../Maze\";\nimport Vec2d from \"../../utils/Vec2d\";\n\nconst WALL_PROBABILITY = 1 / 4;\n\nconst generate = function* (cols: number, rows: number): Generator<Maze> {\n  let maze = Maze.empty(cols, rows);\n\n  for (let row = 0; row < rows; ++row) {\n    for (let col = 0; col < cols; ++col) {\n      if (Math.random() < WALL_PROBABILITY) {\n        yield (maze = maze.toggleWall(new Vec2d(col, row)));\n      }\n    }\n  }\n};\n\nconst random = { name: \"Random\", generate };\n\nexport default random;\n","import Maze from \"../maze/Maze\";\nimport Vec2d from \"../utils/Vec2d\";\n\nexport type SearchParams = {\n  maze: Maze;\n  start: Vec2d;\n  target: Vec2d;\n};\n\nexport type SearchNode = {\n  pos: Vec2d;\n  prev?: SearchNode;\n};\n\nexport type SearchState = {\n  current: SearchNode;\n  visited: Set<string>;\n  found: boolean;\n};\n\nexport const rewind = (node: SearchNode): Vec2d[] => {\n  const path = [];\n\n  while (node.prev) {\n    path.unshift(node.pos);\n    node = node.prev;\n  }\n\n  return path;\n};\n","export default class Queue<T> {\n  constructor(private items: T[] = []) {}\n\n  public enqueue(...items: T[]): void {\n    this.items.push(...items);\n  }\n\n  public dequeue(): T {\n    if (this.isEmpty()) {\n      throw new Error(\"Cannot dequeue empty queue\");\n    }\n\n    return this.items.shift() as T;\n  }\n\n  public isEmpty(): boolean {\n    return this.size === 0;\n  }\n\n  public get size(): number {\n    return this.items.length;\n  }\n}\n","import { SearchNode, SearchParams, SearchState, rewind } from \"../\";\nimport { getAdjacentPathPositions } from \"../../maze\";\nimport Queue from \"./utils/Queue\";\n\nconst search = function* ({ maze, start, target }: SearchParams): Generator<SearchState> {\n  const queue = new Queue<SearchNode>([{ pos: start }]);\n  const visited = new Set<string>();\n\n  while (!queue.isEmpty()) {\n    const node = queue.dequeue();\n    const hash = node.pos.toString();\n\n    if (visited.has(hash)) {\n      continue;\n    }\n\n    yield { current: node, visited: visited.add(hash), found: target.equals(node.pos) };\n\n    for (const neighbour of getAdjacentPathPositions(maze, node.pos)) {\n      queue.enqueue({ pos: neighbour, prev: node });\n    }\n  }\n};\n\nconst breadthFirstSearch = { name: \"Breadth-first search\", search, rewind };\n\nexport default breadthFirstSearch;\n","import React, { useRef, useState } from \"react\";\nimport { findEmptySquareInBounds } from \"../maze\";\nimport Maze from \"../maze/Maze\";\nimport mazeGenerators from \"../maze/generators\";\nimport searchMethods from \"../search/methods\";\nimport Vec2d from \"../utils/Vec2d\";\nimport sleep from \"./utils/sleep\";\nimport Controls from \"./Controls\";\nimport MazeComponent from \"./Maze\";\n\ntype PathFinderProps = {\n  mazeSize: {\n    cols: number;\n    rows: number;\n  };\n  mazeStyle: React.CSSProperties;\n};\n\nenum MovingState {\n  None,\n  Start,\n  Target,\n  Weight,\n}\n\nconst getInitialMaze = (cols: number, rows: number) => Maze.empty(cols, rows);\nconst getInitialStart = (cols: number, rows: number) => new Vec2d(Math.floor(cols / 4) - 1, Math.floor(rows / 2));\nconst getInitialTarget = (cols: number, rows: number) => new Vec2d(cols - Math.floor(cols / 4), Math.floor(rows / 2));\nconst getInitialVisited = () => new Set<string>();\nconst getInitialSolution = () => new Set<string>();\n\nconst PathFinder = ({ mazeSize: { cols, rows }, mazeStyle }: PathFinderProps): JSX.Element => {\n  const [maze, setMaze] = useState(getInitialMaze(cols, rows));\n  const [start, setStart] = useState(getInitialStart(cols, rows));\n  const [target, setTarget] = useState(getInitialTarget(cols, rows));\n  const [visited, setVisited] = useState(getInitialVisited());\n  const [solution, setSolution] = useState(getInitialSolution());\n\n  const [, setFinishedAt] = useState(Date.now);\n  const [moving, setMoving] = useState(MovingState.None);\n  const [isDrawing, setIsDrawing] = useState(false);\n  const [isGenerating, setIsGenerating] = useState(false);\n\n  const [mazeGenerator, setMazeGenerator] = useState(\"recursiveDivision\");\n  const [searchMethod, setSearchMethod] = useState(\"breadthFirstSearch\");\n\n  const currentSearch = useRef<Generator | null>(null);\n  const hasCurrentSearch = (): boolean => currentSearch.current !== null;\n  const setCurrentSearch = (s: Generator | null): void => void (currentSearch.current = s);\n\n  const _isSearching = useRef(false);\n  const isSearching = (): boolean => _isSearching.current;\n  const setIsSearching = (r: boolean): void => void (_isSearching.current = r);\n\n  const handleMouseUp = (): void => {\n    setMoving(MovingState.None);\n    setIsDrawing(false);\n  };\n\n  const handleMouseDown = (pos: Vec2d): void => {\n    if (isSearching()) {\n      return;\n    }\n\n    if (pos.equals(start)) {\n      return setMoving(MovingState.Start);\n    }\n\n    if (pos.equals(target)) {\n      return setMoving(MovingState.Target);\n    }\n\n    setIsDrawing(true);\n    setMaze(maze.toggleWall(pos));\n  };\n\n  const handleMouseEnter = (pos: Vec2d): void => {\n    if (moving !== MovingState.None && maze.isEmpty(pos)) {\n      return moving === MovingState.Start ? setStart(pos) : setTarget(pos);\n    }\n\n    if (isDrawing && !pos.equals(start) && !pos.equals(target)) {\n      setMaze(maze.toggleWall(pos));\n    }\n  };\n\n  const handleStartClick = async (): Promise<void> => {\n    setIsSearching(true);\n\n    if (!hasCurrentSearch()) {\n      setCurrentSearch(generateSearch());\n      setSolution(getInitialSolution());\n    }\n\n    let next;\n\n    do {\n      // @ts-ignore\n      next = currentSearch.current.next();\n      if (next.value) next.value();\n      if (!isSearching()) return;\n      await sleep(8);\n    } while (!next.done);\n\n    setCurrentSearch(null);\n    setIsSearching(false);\n    setFinishedAt(Date.now);\n  };\n\n  const generateSearch = function* (): Generator<() => void> {\n    const method = searchMethods[searchMethod];\n\n    for (const state of method.search({ maze, start, target })) {\n      yield () => setVisited(new Set([...state.visited]));\n\n      if (state.found) {\n        const solution = getInitialSolution();\n        setSolution(solution);\n\n        for (const pos of method.rewind(state.current)) {\n          yield () => setSolution(new Set([...solution.add(pos.toString())]));\n        }\n\n        return;\n      }\n    }\n  };\n\n  const handleStopClick = (): void => setIsSearching(false);\n\n  const handleClearClick = (): void => {\n    setMaze(getInitialMaze(cols, rows));\n    setStart(getInitialStart(cols, rows));\n    setTarget(getInitialTarget(cols, rows));\n    setVisited(getInitialVisited());\n    setSolution(getInitialSolution());\n    setCurrentSearch(null);\n    setIsGenerating(false);\n    setIsSearching(false);\n  };\n\n  const handleGenerateClick = async (): Promise<void> => {\n    handleClearClick();\n    setIsGenerating(true);\n\n    const outOfBounds = new Vec2d(cols, rows);\n    setStart(outOfBounds);\n    setTarget(outOfBounds);\n\n    let finalMaze = maze;\n\n    for (const maze of mazeGenerators[mazeGenerator].generate(cols, rows)) {\n      setMaze(maze);\n      finalMaze = maze;\n      await sleep(8);\n    }\n\n    setStart(findEmptySquareInBounds(finalMaze, Vec2d.origin(), new Vec2d(Math.floor(cols / 3), rows)));\n    setTarget(findEmptySquareInBounds(finalMaze, new Vec2d(Math.floor((cols * 2) / 3), 0), new Vec2d(cols, rows)));\n    setIsGenerating(false);\n  };\n\n  const handleMazeGeneratorSelect = (e: any): void => setMazeGenerator(e.target.value);\n  const handleSearchMethodSelect = (e: any): void => setSearchMethod(e.target.value);\n\n  const getSquareClassName = (pos: Vec2d): string => {\n    if (maze.isWall(pos)) {\n      return \"is-wall\";\n    }\n\n    if (start.equals(pos)) {\n      return \"is-start\";\n    }\n\n    if (target.equals(pos)) {\n      return \"is-target\";\n    }\n\n    if (solution.has(pos.toString())) {\n      return \"is-solution\";\n    }\n\n    if (visited.has(pos.toString())) {\n      return \"is-visited\";\n    }\n\n    return \"\";\n  };\n\n  return (\n    <div\n      className={`PathFinder${\n        isGenerating ? \" is-generating is-\" + mazeGenerator : isSearching() ? \" is-searching\" : \"\"\n      }`}\n    >\n      <Controls\n        isGenerating={isGenerating}\n        isSearching={isSearching()}\n        onStartClick={handleStartClick}\n        onStopClick={handleStopClick}\n        onClearClick={handleClearClick}\n        onGenerateClick={handleGenerateClick}\n        selectedMazeGenerator={mazeGenerator}\n        selectedSearchMethod={searchMethod}\n        onMazeGeneratorSelect={handleMazeGeneratorSelect}\n        onSearchMethodSelect={handleSearchMethodSelect}\n      />\n      <MazeComponent\n        numRows={rows}\n        numCols={cols}\n        style={mazeStyle}\n        getSquareClassName={getSquareClassName}\n        onMouseUp={handleMouseUp}\n        onMouseDown={handleMouseDown}\n        onMouseEnter={handleMouseEnter}\n      />\n    </div>\n  );\n};\n\nexport default PathFinder;\n","import PriorityQueue from \"ts-priority-queue\";\nimport { SearchNode, SearchParams, SearchState, rewind } from \"../\";\nimport { getAdjacentPathPositions } from \"../../maze\";\nimport Vec2d from \"../../utils/Vec2d\";\n\nconst search = function* ({ maze, start, target }: SearchParams): Generator<SearchState> {\n  const queue = new PriorityQueue<SearchNode>({\n    comparator: (a, b) => manhattanDistance(a.pos, target) - manhattanDistance(b.pos, target),\n    initialValues: [{ pos: start }],\n  });\n  const visited = new Set<string>();\n\n  while (queue.length > 0) {\n    const node = queue.dequeue();\n    const hash = node.pos.toString();\n\n    if (visited.has(hash)) {\n      continue;\n    }\n\n    yield { current: node, visited: visited.add(hash), found: target.equals(node.pos) };\n\n    for (const neighbour of getAdjacentPathPositions(maze, node.pos)) {\n      queue.queue({ pos: neighbour, prev: node });\n    }\n  }\n};\n\nconst manhattanDistance = (a: Vec2d, b: Vec2d): number => Math.abs(a.x - b.x) + Math.abs(a.y - b.y);\n\nconst greedyBestFirstSearch = { name: \"Greedy best-first search\", search, rewind };\n\nexport default greedyBestFirstSearch;\n","import { SearchNode, SearchParams, SearchState, rewind } from \"../\";\nimport { getAdjacentPathPositions } from \"../../maze\";\n\nconst search = function* (params: SearchParams): Generator<SearchState> {\n  yield* dfs({ pos: params.start }, new Set(), params);\n};\n\nconst dfs = function* (node: SearchNode, visited: Set<string>, params: SearchParams): Generator<SearchState> {\n  const hash = node.pos.toString();\n\n  if (visited.has(hash)) {\n    return;\n  }\n\n  yield { current: node, visited: visited.add(hash), found: params.target.equals(node.pos) };\n\n  for (const neighbour of getAdjacentPathPositions(params.maze, node.pos)) {\n    yield* dfs({ pos: neighbour, prev: node }, visited, params);\n  }\n};\n\nconst depthFirstSearch = { name: \"Depth-first search\", search, rewind };\n\nexport default depthFirstSearch;\n","import { SearchNode, SearchParams, SearchState } from \"../\";\nimport breadthFirstSearch from \"./breadth-first-search\";\nimport biDirectionalBfs from \"./bidirectional-bfs\";\nimport greedBestFirstSearch from \"./greedy-best-first-search\";\nimport depthFirstSearch from \"./depth-first-search\";\nimport Vec2d from \"../../utils/Vec2d\";\n\ntype SearchMethod = {\n  name: string;\n  search: (params: SearchParams) => Generator<SearchState>;\n  rewind: (node: SearchNode) => Vec2d[];\n};\n\nconst methods: { [key: string]: SearchMethod } = {\n  breadthFirstSearch,\n  biDirectionalBfs,\n  greedBestFirstSearch,\n  depthFirstSearch,\n};\n\nexport default methods;\n","const sleep = async (ms: number): Promise<void> => {\n  await new Promise((r) => setTimeout(r, ms));\n};\n\nexport default sleep;\n","import { FormEvent } from \"react\";\nimport mazeGenerators from \"../maze/generators\";\nimport searchMethods from \"../search/methods\";\n\ntype ControlsProps = {\n  isGenerating: boolean;\n  isSearching: boolean;\n  onStartClick: () => void;\n  onStopClick: () => void;\n  onClearClick: () => void;\n  onGenerateClick: () => void;\n  selectedMazeGenerator: string;\n  selectedSearchMethod: string;\n  onMazeGeneratorSelect: (e: FormEvent<HTMLSelectElement>) => void;\n  onSearchMethodSelect: (e: FormEvent<HTMLSelectElement>) => void;\n};\n\nconst Controls = (props: ControlsProps): JSX.Element => (\n  <div className=\"Controls\">\n    <fieldset>\n      <legend>Maze generator</legend>\n      <select onChange={props.onMazeGeneratorSelect} value={props.selectedMazeGenerator}>\n        {Object.entries(mazeGenerators).map(([key, generator]) => (\n          <option key={key} value={key}>\n            {generator.name}\n          </option>\n        ))}\n      </select>\n      <button onClick={props.onGenerateClick} disabled={props.isSearching || props.isGenerating}>\n        Generate\n      </button>\n      <button onClick={props.onClearClick} disabled={props.isSearching || props.isGenerating}>\n        Clear\n      </button>\n    </fieldset>\n    <fieldset>\n      <legend>Search method</legend>\n      <select onChange={props.onSearchMethodSelect} value={props.selectedSearchMethod}>\n        {Object.entries(searchMethods).map(([key, method]) => (\n          <option key={key} value={key}>\n            {method.name}\n          </option>\n        ))}\n      </select>\n      <button onClick={props.isSearching ? props.onStopClick : props.onStartClick} disabled={props.isGenerating}>\n        {props.isSearching ? \"Stop\" : \"Start\"}\n      </button>\n    </fieldset>\n  </div>\n);\n\nexport default Controls;\n","import React from \"react\";\nimport Vec2d from \"../utils/Vec2d\";\n\ntype MazeProps = {\n  numRows: number;\n  numCols: number;\n  style: React.CSSProperties;\n  getSquareClassName: (pos: Vec2d) => string;\n  onMouseUp: (pos: Vec2d) => void;\n  onMouseDown: (pos: Vec2d) => void;\n  onMouseEnter: (pos: Vec2d) => void;\n};\n\nconst Maze = (props: MazeProps): JSX.Element => {\n  const squares = [];\n\n  for (let row = 0; row < props.numRows; ++row) {\n    for (let col = 0; col < props.numCols; ++col) {\n      const pos = new Vec2d(col, row);\n\n      squares.push(\n        <div\n          key={pos.toString()}\n          className={props.getSquareClassName(pos)}\n          onMouseUp={() => props.onMouseUp(pos)}\n          onMouseDown={() => props.onMouseDown(pos)}\n          onMouseEnter={() => props.onMouseEnter(pos)}\n        />\n      );\n    }\n  }\n\n  return (\n    <div className=\"Maze\" style={props.style}>\n      {squares}\n    </div>\n  );\n};\n\nexport default Maze;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport PathFinder from \"./Components/PathFinder\";\nimport \"./index.css\";\n\nconst buildPathFinderProps = () => {\n  // @ts-ignore\n  const bodyPadding = parseInt(getComputedStyle(document.body).getPropertyValue(\"padding-left\"));\n  // @ts-ignore\n  const headerHeight = parseInt(getComputedStyle(document.querySelector(\"header\")).getPropertyValue(\"height\"));\n  const squareWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue(\"--square-width\"));\n\n  const cols = Math.floor((window.innerWidth - 2 * bodyPadding) / squareWidth);\n  const rows = Math.max(5, Math.floor((window.innerHeight - 3 * headerHeight) / squareWidth));\n\n  return {\n    mazeSize: { cols, rows },\n    mazeStyle: {\n      gridTemplateColumns: `repeat(${cols}, ${squareWidth}px)`,\n      gridTemplateRows: `repeat(${rows}, ${squareWidth}px)`,\n    },\n  };\n};\n\nReactDOM.render(\n  <React.StrictMode>\n    <PathFinder {...buildPathFinderProps()} />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n"],"sourceRoot":""}