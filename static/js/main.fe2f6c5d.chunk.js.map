{"version":3,"sources":["search/methods/bidirectional-bfs.ts","search/utils/Vec2d.ts","search/SearchMap.ts","search/index.ts","search/utils/Queue.ts","search/methods/breadth-first-search.ts","Components/PathFinder.tsx","search/methods/greedy-best-first-search.ts","search/methods/index.ts","Components/utils/sleep.ts","Components/Controls.tsx","Components/PathMap.tsx","index.tsx"],"names":["Direction","nodeHistory","Vec2d","x","y","v","this","maxX","maxY","Math","floor","random","SearchMap","numCols","numRows","walls","Set","pos","isWithinBounds","Error","toString","map","isWall","delete","add","has","neighbours","dx","dy","neighbour","push","rewind","node","path","prev","unshift","Queue","items","isEmpty","shift","size","length","bfs","name","start","target","visited","queue","searchNode","dequeue","current","found","equals","getNeighbours","neighbourPos","hash","enqueue","f","MovingState","biDirBfs","visitedForward","visitedBackward","direction","Forward","Backward","neighbourNode","intersection","filter","sort","defaultRewind","reverse","manhattanDistance","a","b","abs","methods","breadthFirstSearch","biDirectionalBfs","PriorityQueue","comparator","initialValues","sleep","ms","Promise","r","setTimeout","Controls","props","className","onClick","onStartClick","onClearClick","onGenerateClick","onChange","onMethodSelect","Object","entries","key","method","value","PathMap","squares","row","col","getSquareClassName","onMouseUp","onMouseDown","onMouseEnter","style","getInitialMap","cols","rows","getInitialStart","getInitialTarget","getInitialVisited","getInitialSolution","PathFinder","mapSize","mapStyle","useState","setMap","setStart","setTarget","setVisited","solution","setSolution","setMethod","None","moving","setMoving","isDrawing","setIsDrawing","handleStartClick","handleClearClick","toggleWall","e","Start","Target","ReactDOM","render","StrictMode","bodyPadding","parseInt","getComputedStyle","document","body","getPropertyValue","headerHeight","querySelector","squareWidth","documentElement","window","innerWidth","innerHeight","gridTemplateColumns","gridTemplateRows","buildPathFinderProps","getElementById"],"mappings":"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","file":"static/js/main.fe2f6c5d.chunk.js","sourcesContent":["import { SearchState, SearchNode, SearchParams, SearchMethod, rewind as defaultRewind } from \"../\";\nimport Queue from \"../utils/Queue\";\nimport Vec2d from \"../utils/Vec2d\";\n\nenum Direction {\n  Forward,\n  Backward,\n}\n\ntype BiDirSearchNode = {\n  searchNode: SearchNode;\n  direction: Direction;\n};\n\nlet nodeHistory: BiDirSearchNode[];\n\nconst start = function* ({ map, start, target }: SearchParams): Generator<SearchState> {\n  nodeHistory = [];\n\n  const visitedForward = new Set<string>([start.toString()]);\n  const visitedBackward = new Set<string>([target.toString()]);\n\n  const queue = new Queue<BiDirSearchNode>([\n    {\n      searchNode: { pos: start },\n      direction: Direction.Forward,\n    },\n    {\n      searchNode: { pos: target },\n      direction: Direction.Backward,\n    },\n  ]);\n\n  while (!queue.isEmpty()) {\n    const { searchNode, direction } = queue.dequeue();\n\n    const found =\n      (direction === Direction.Forward && visitedBackward.has(searchNode.pos.toString())) ||\n      (direction === Direction.Backward && visitedForward.has(searchNode.pos.toString()));\n\n    yield { current: searchNode, visited: new Set([...visitedForward, ...visitedBackward]), found };\n\n    for (const neighbourPos of map.getNeighbours(searchNode.pos)) {\n      const hash = neighbourPos.toString();\n      let enqueue = false;\n\n      if (direction === Direction.Forward) {\n        if (!visitedForward.has(hash)) {\n          visitedForward.add(hash);\n          enqueue = true;\n        }\n      } else if (!visitedBackward.has(hash)) {\n        visitedBackward.add(hash);\n        enqueue = true;\n      }\n\n      if (enqueue) {\n        const neighbourNode = {\n          searchNode: {\n            pos: neighbourPos,\n            prev: searchNode,\n          },\n          direction,\n        };\n\n        nodeHistory.push(neighbourNode);\n        queue.enqueue(neighbourNode);\n      }\n    }\n  }\n};\n\nconst rewind = (node: SearchNode): Vec2d[] => {\n  const intersection = nodeHistory\n    .filter(({ searchNode }) => node.pos.equals(searchNode.pos))\n    .sort(({ direction }) => (direction === Direction.Forward ? -1 : 1));\n\n  return [...defaultRewind(intersection[0].searchNode), ...defaultRewind(intersection[1].searchNode).reverse()];\n};\n\nconst biDirBfs: SearchMethod = { name: \"Bidirectional BFS\", start, rewind };\n\nexport default biDirBfs;\n","export default class Vec2d {\n  constructor(readonly x: number, readonly y: number) {}\n\n  public add(v: Vec2d): Vec2d {\n    return new Vec2d(this.x + v.x, this.y + v.y);\n  }\n\n  public equals(v: Vec2d): boolean {\n    return this.x === v.x && this.y === v.y;\n  }\n\n  public toString(): string {\n    return `(${this.x}, ${this.y})`;\n  }\n\n  public static random(maxX: number, maxY: number): Vec2d {\n    return new Vec2d(Math.floor(Math.random() * maxX), Math.floor(Math.random() * maxY));\n  }\n}\n","import Vec2d from \"./utils/Vec2d\";\n\nexport default class SearchMap {\n  private walls = new Set<string>();\n\n  public constructor(readonly numCols: number, readonly numRows: number) {}\n\n  public toggleWall(pos: Vec2d): SearchMap {\n    if (!this.isWithinBounds(pos)) {\n      throw new Error(`Out of bounds: ${pos.toString()}`);\n    }\n\n    const map = new SearchMap(this.numCols, this.numRows);\n    map.walls = new Set([...this.walls]);\n\n    if (map.isWall(pos)) {\n      map.walls.delete(pos.toString());\n    } else {\n      map.walls.add(pos.toString());\n    }\n\n    return map;\n  }\n\n  public isWall(pos: Vec2d): boolean {\n    return this.walls.has(pos.toString());\n  }\n\n  public getNeighbours(pos: Vec2d): Vec2d[] {\n    const neighbours = [];\n\n    const dirs = [\n      { dx: 1, dy: 0 },\n      { dx: 0, dy: 1 },\n      { dx: -1, dy: 0 },\n      { dx: 0, dy: -1 },\n    ];\n\n    for (const { dx, dy } of dirs) {\n      const neighbour = pos.add(new Vec2d(dx, dy));\n\n      if (!this.isWithinBounds(neighbour)) {\n        continue;\n      }\n\n      if (!this.isWall(neighbour)) {\n        neighbours.push(neighbour);\n      }\n    }\n\n    return neighbours;\n  }\n\n  private isWithinBounds(pos: Vec2d): boolean {\n    return pos.x >= 0 && pos.y >= 0 && pos.x < this.numCols && pos.y < this.numRows;\n  }\n}\n","import SearchMap from \"./SearchMap\";\nimport Vec2d from \"./utils/Vec2d\";\n\nexport type SearchParams = {\n  map: SearchMap;\n  start: Vec2d;\n  target: Vec2d;\n};\n\nexport type SearchNode = {\n  pos: Vec2d;\n  prev?: SearchNode;\n};\n\nexport type SearchState = {\n  current: SearchNode;\n  visited: Set<string>;\n  found: boolean;\n};\n\nexport type SearchMethod = {\n  name: string;\n  start: (params: SearchParams) => Generator<SearchState>;\n  rewind: (node: SearchNode) => Vec2d[];\n};\n\nexport const rewind = (node: SearchNode): Vec2d[] => {\n  const path = [];\n\n  while (node.prev) {\n    path.unshift(node.pos);\n    node = node.prev;\n  }\n\n  return path;\n};\n","export default class Queue<T> {\n  constructor(private items: T[] = []) {}\n\n  public enqueue(...items: T[]): void {\n    this.items.push(...items);\n  }\n\n  public dequeue(): T {\n    if (this.isEmpty()) {\n      throw new Error(\"Cannot dequeue empty queue\");\n    }\n\n    return this.items.shift() as T;\n  }\n\n  public isEmpty(): boolean {\n    return this.size === 0;\n  }\n\n  public get size(): number {\n    return this.items.length;\n  }\n}\n","import { SearchState, SearchNode, SearchParams, SearchMethod, rewind } from \"../\";\nimport Queue from \"../utils/Queue\";\n\nconst start = function* ({ map, start, target }: SearchParams): Generator<SearchState> {\n  const visited = new Set<string>([start.toString()]);\n  const queue = new Queue<SearchNode>([{ pos: start }]);\n\n  while (!queue.isEmpty()) {\n    const searchNode = queue.dequeue();\n\n    yield { current: searchNode, visited, found: searchNode.pos.equals(target) };\n\n    for (const neighbourPos of map.getNeighbours(searchNode.pos)) {\n      const hash = neighbourPos.toString();\n\n      if (!visited.has(hash)) {\n        visited.add(hash);\n        queue.enqueue({\n          pos: neighbourPos,\n          prev: searchNode,\n        });\n      }\n    }\n  }\n};\n\nconst bfs: SearchMethod = { name: \"Breadth-first search\", start, rewind };\n\nexport default bfs;\n","import React, { useState } from \"react\";\nimport SearchMap from \"../search/SearchMap\";\nimport methods from \"../search/methods\";\nimport Vec2d from \"../search/utils/Vec2d\";\nimport sleep from \"./utils/sleep\";\nimport Controls from \"./Controls\";\nimport PathMap from \"./PathMap\";\n\ntype PathFinderProps = {\n  mapSize: {\n    cols: number;\n    rows: number;\n  };\n  mapStyle: React.CSSProperties;\n};\n\nenum MovingState {\n  None,\n  Start,\n  Target,\n}\n\nconst getInitialMap = (cols: number, rows: number) => new SearchMap(cols, rows);\nconst getInitialStart = (cols: number, rows: number) => new Vec2d(Math.floor(cols / 4) - 1, Math.floor(rows / 2) - 1);\nconst getInitialTarget = (cols: number, rows: number) => new Vec2d(cols - Math.floor(cols / 4), Math.floor(rows / 2) - 1);\nconst getInitialVisited = () => new Set<string>();\nconst getInitialSolution = () => new Set<string>();\n\nconst PathFinder = ({ mapSize: { cols, rows }, mapStyle }: PathFinderProps): JSX.Element => {\n  const [map, setMap] = useState(getInitialMap(cols, rows));\n  const [start, setStart] = useState(getInitialStart(cols, rows));\n  const [target, setTarget] = useState(getInitialTarget(cols, rows));\n  const [visited, setVisited] = useState(getInitialVisited());\n  const [solution, setSolution] = useState(getInitialSolution());\n\n  const [method, setMethod] = useState(\"breadth-first-search\");\n  const [moving, setMoving] = useState(MovingState.None);\n  const [isDrawing, setIsDrawing] = useState(false);\n\n  const handleMouseUp = (): void => {\n    setMoving(MovingState.None);\n    setIsDrawing(false);\n  };\n\n  const handleMouseDown = (pos: Vec2d): void => {\n    if (pos.equals(start)) {\n      setMoving(MovingState.Start);\n      return;\n    }\n\n    if (pos.equals(target)) {\n      setMoving(MovingState.Target);\n      return;\n    }\n\n    setIsDrawing(true);\n    setMap(map.toggleWall(pos));\n  };\n\n  const handleMouseEnter = (pos: Vec2d): void => {\n    if (moving === MovingState.Start) {\n      setStart(pos);\n      return;\n    }\n\n    if (moving === MovingState.Target) {\n      setTarget(pos);\n      return;\n    }\n\n    if (isDrawing && !pos.equals(start) && !pos.equals(target)) {\n      setMap(map.toggleWall(pos));\n    }\n  };\n\n  const handleStartClick = async (): Promise<void> => {\n    const solution = getInitialSolution();\n    setSolution(solution);\n\n    // @ts-ignore\n    for (const { current, found, visited } of methods[method].start({ map, start, target })) {\n      setVisited(new Set([...visited]));\n\n      if (found) {\n        // @ts-ignore\n        for (const pos of methods[method].rewind(current)) {\n          setSolution(new Set([...solution.add(pos.toString())]));\n          await sleep(15);\n        }\n\n        break;\n      }\n\n      await sleep(10);\n    }\n  };\n\n  const handleClearClick = (): void => {\n    setMap(getInitialMap(cols, rows));\n    setStart(getInitialStart(cols, rows));\n    setTarget(getInitialTarget(cols, rows));\n    setVisited(getInitialVisited());\n    setSolution(getInitialSolution());\n  };\n\n  const handleGenerateClick = (): void => {\n    handleClearClick();\n\n    const start = Vec2d.random(cols, rows);\n    const target = Vec2d.random(cols, rows);\n\n    setStart(start);\n    setTarget(target);\n\n    let map = getInitialMap(cols, rows);\n\n    for (let row = 0; row < rows; ++row) {\n      for (let col = 0; col < cols; ++col) {\n        const pos = new Vec2d(col, row);\n\n        if (start.equals(pos) || target.equals(pos)) {\n          continue;\n        }\n\n        if (Math.random() < 0.25) {\n          map = map.toggleWall(pos);\n          setMap(map);\n        }\n      }\n    }\n  };\n\n  const handleMethodSelect = (e: any): void => {\n    setMethod(e.target.value);\n  };\n\n  const getSquareClassName = (pos: Vec2d): string => {\n    if (map.isWall(pos)) {\n      return \"wall\";\n    }\n\n    if (start.equals(pos)) {\n      return \"start\";\n    }\n\n    if (target.equals(pos)) {\n      return \"target\";\n    }\n\n    if (solution.has(pos.toString())) {\n      return \"solution\";\n    }\n\n    if (visited.has(pos.toString())) {\n      return \"visited\";\n    }\n\n    return \"\";\n  };\n\n  return (\n    <div className=\"PathFinder\">\n      <Controls\n        onStartClick={handleStartClick}\n        onClearClick={handleClearClick}\n        onGenerateClick={handleGenerateClick}\n        onMethodSelect={handleMethodSelect}\n      />\n      <PathMap\n        numRows={rows}\n        numCols={cols}\n        style={mapStyle}\n        getSquareClassName={getSquareClassName}\n        onMouseUp={handleMouseUp}\n        onMouseDown={handleMouseDown}\n        onMouseEnter={handleMouseEnter}\n      />\n    </div>\n  );\n};\n\nexport default PathFinder;\n","import PriorityQueue from \"ts-priority-queue\";\nimport { SearchState, SearchNode, SearchParams, SearchMethod, rewind } from \"../\";\nimport Vec2d from \"../utils/Vec2d\";\n\nconst manhattanDistance = (a: Vec2d, b: Vec2d): number => Math.abs(a.x - b.x) + Math.abs(a.y - b.y);\n\nconst start = function* ({ map, start, target }: SearchParams): Generator<SearchState> {\n  const visited = new Set<string>([start.toString()]);\n\n  const queue = new PriorityQueue<SearchNode>({\n    comparator: (a, b) => manhattanDistance(a.pos, target) - manhattanDistance(b.pos, target),\n    initialValues: [{ pos: start }],\n  });\n\n  while (queue.length > 0) {\n    const searchNode = queue.dequeue();\n\n    yield { current: searchNode, visited, found: searchNode.pos.equals(target) };\n\n    for (const neighbourPos of map.getNeighbours(searchNode.pos)) {\n      const hash = neighbourPos.toString();\n\n      if (!visited.has(hash)) {\n        visited.add(hash);\n        queue.queue({\n          pos: neighbourPos,\n          prev: searchNode,\n        });\n      }\n    }\n  }\n};\n\nconst greedyBestFirstSearch: SearchMethod = { name: \"Greedy best-first search\", start, rewind };\n\nexport default greedyBestFirstSearch;\n","import breadthFirstSearch from \"./breadth-first-search\";\nimport biDirectionalBfs from \"./bidirectional-bfs\";\nimport greedBestFirstSearch from \"./greedy-best-first-search\";\n\nconst methods = {\n  \"breadth-first-search\": breadthFirstSearch,\n  \"bidirectional-bfs\": biDirectionalBfs,\n  \"greedy-best-first-search\": greedBestFirstSearch,\n};\n\nexport default methods;\n","const sleep = async (ms: number): Promise<void> => {\n  await new Promise((r) => setTimeout(r, ms));\n};\n\nexport default sleep;\n","import { FormEvent } from \"react\";\nimport methods from \"../search/methods\";\n\ntype ControlsProps = {\n  onStartClick: () => void;\n  onClearClick: () => void;\n  onGenerateClick: () => void;\n  onMethodSelect: (e: FormEvent<HTMLSelectElement>) => void;\n};\n\nconst Controls = (props: ControlsProps): JSX.Element => (\n  <div className=\"Controls\">\n    <button onClick={props.onStartClick}>Start</button>\n    <button onClick={props.onClearClick}>Clear</button>\n    <button onClick={props.onGenerateClick}>Generate</button>\n    <select onChange={props.onMethodSelect}>\n      {Object.entries(methods).map(([key, method]) => (\n        <option key={key} value={key}>\n          {method.name}\n        </option>\n      ))}\n    </select>\n  </div>\n);\n\nexport default Controls;\n","import React from \"react\";\nimport Vec2d from \"../search/utils/Vec2d\";\n\ntype PathMapProps = {\n  numRows: number;\n  numCols: number;\n  style: React.CSSProperties;\n  getSquareClassName: (pos: Vec2d) => string;\n  onMouseUp: (pos: Vec2d) => void;\n  onMouseDown: (pos: Vec2d) => void;\n  onMouseEnter: (pos: Vec2d) => void;\n};\n\nconst PathMap = (props: PathMapProps): JSX.Element => {\n  const squares = [];\n\n  for (let row = 0; row < props.numRows; ++row) {\n    for (let col = 0; col < props.numCols; ++col) {\n      const pos = new Vec2d(col, row);\n\n      squares.push(\n        <div\n          key={pos.toString()}\n          className={props.getSquareClassName(pos)}\n          onMouseUp={() => props.onMouseUp(pos)}\n          onMouseDown={() => props.onMouseDown(pos)}\n          onMouseEnter={() => props.onMouseEnter(pos)}\n        />\n      );\n    }\n  }\n\n  return (\n    <div className=\"PathMap\" style={props.style}>\n      {squares}\n    </div>\n  );\n};\n\nexport default PathMap;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport PathFinder from \"./Components/PathFinder\";\nimport \"./index.css\";\n\nconst buildPathFinderProps = () => {\n  // @ts-ignore\n  const bodyPadding = parseInt(getComputedStyle(document.body).getPropertyValue(\"padding-left\"));\n  // @ts-ignore\n  const headerHeight = parseInt(getComputedStyle(document.querySelector(\"header\")).getPropertyValue(\"height\"));\n  const squareWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue(\"--map-square-width\"));\n\n  const cols = Math.floor((window.innerWidth - 2 * bodyPadding) / squareWidth);\n  const rows = Math.floor((window.innerHeight - 2 * headerHeight - bodyPadding) / squareWidth);\n\n  return {\n    mapSize: { cols, rows },\n    mapStyle: {\n      gridTemplateColumns: `repeat(${cols}, ${squareWidth}px)`,\n      gridTemplateRows: `repeat(${rows}, ${squareWidth}px)`,\n    },\n  };\n};\n\nReactDOM.render(\n  <React.StrictMode>\n    <PathFinder {...buildPathFinderProps()} />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n"],"sourceRoot":""}