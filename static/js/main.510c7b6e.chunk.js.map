{"version":3,"sources":["utils/random.ts","utils/Vec2d.ts","maze/index.ts","utils/CompoundSet.ts","utils/CompoundMap.ts","maze/generators/depth-first-search.ts","maze/generators/recursive-division.ts","search/methods/bidirectional-bfs.ts","maze/Maze.ts","maze/generators/prims.ts","maze/generators/binary-tree.ts","maze/generators/index.ts","maze/generators/random.ts","search/index.ts","search/methods/utils/Queue.ts","search/methods/breadth-first-search.ts","Components/PathFinder.tsx","search/methods/greedy-best-first-search.ts","search/methods/dijkstra.ts","search/methods/a-star.ts","search/methods/depth-first-search.ts","search/methods/index.ts","Components/utils/sleep.ts","Components/Controls.tsx","Components/Maze.tsx","index.tsx"],"names":["random","max","Math","floor","randomEven","ceil","randomElement","elements","length","shuffle","arr","currIdx","randIdx","Vec2d","x","y","v","this","from","to","DIRECTIONS","dx","dy","getAdjacentMazePositions","maze","pos","dist","map","add","getAdjacentPositions","filter","isWithinBounds","getAdjacentWallPositions","isWall","getAdjacentPathPositions","findEmptySquareInBounds","square","Symbol","iterator","CompoundSet","initial","set","Map","val","toKey","has","delete","values","JSON","stringify","toStringTag","Direction","nodeHistory","CompoundMap","entries","items","key","value","clear","get","callbackfn","thisArg","call","size","constructor","name","Maze","numCols","numRows","walls","Set","weights","isWeight","toggleWalls","positions","clone","Error","toString","weight","empty","row","col","push","prims","generate","cols","rows","full","frontier","origin","some","cell","toggleWall","adjPath","randomPath","binaryTree","wallLeftOrUp","start","dfs","visited","neighbour","f","depthFirstSearch","divide","width","height","xy","vertical","gap","wallFrom","wallTo","direction","equals","generators","recursiveDivision","rewind","node","path","prev","unshift","Queue","isEmpty","shift","breadthFirstSearch","search","target","queue","dequeue","current","found","enqueue","isWeighted","DragType","biDirBfs","Forward","Backward","visitedForward","visitedBackward","neighbourNode","intersection","n","sort","defaultRewind","reverse","PriorityQueue","comparator","a","b","manhattanDistance","initialValues","abs","greedyBestFirstSearch","dijkstra","distance","getWeight","distFromStart","distToTarget","euclideanDistance","sqrt","aStar","params","methods","biDirectionalBfs","greedBestFirstSearch","sleep","ms","Promise","r","setTimeout","Controls","props","className","id","onChange","onMazeGeneratorSelect","selectedMazeGenerator","Object","mazeGenerators","generator","onClick","onGenerateClick","disabled","isSearching","isGenerating","onClearClick","onSearchMethodSelect","selectedSearchMethod","searchMethods","method","onStopClick","onStartClick","MazeComponent","squares","getSquareClassName","data-weight","onMouseUp","onMouseDown","onMouseEnter","onDoubleClick","style","getInitialDrag","type","None","dragged","getInitialMaze","getInitialStart","getInitialTarget","getInitialVisited","getInitialSolution","PathFinder","mazeSize","mazeStyle","useState","setMaze","setStart","setTarget","setVisited","solution","setSolution","drag","setDrag","beginDrag","setDragPos","Date","now","setFinishedAt","setIsGenerating","mazeGenerator","setMazeGenerator","searchMethod","setSearchMethod","currentSearch","useRef","setCurrentSearch","s","_isSearching","setIsSearching","handleStartClick","generateSearch","next","done","state","handleClearClick","handleGenerateClick","outOfBounds","finalMaze","e","clearWeights","setWeight","Start","Target","Weight","Drawing","isStartOrTarget","undefined","removeWeight","isEmbedMode","window","location","indexOf","document","createElement","appendChild","createTextNode","colourScheme","head","getElementsByTagName","getSizeFromUrl","URLSearchParams","parseInt","ReactDOM","render","StrictMode","squareWidth","getComputedStyle","documentElement","getPropertyValue","bodyPadding","body","innerWidth","headerHeight","querySelector","innerHeight","gridTemplateColumns","gridTemplateRows","buildPathFinderProps","getElementById"],"mappings":"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","file":"static/js/main.510c7b6e.chunk.js","sourcesContent":["export const random = (max: number): number => Math.floor(Math.random() * max);\n\nexport const randomEven = (max: number): number => 2 * random(Math.ceil(max / 2));\n\nexport const randomElement = <T>(elements: T[]): T => elements[random(elements.length)];\n\nexport const shuffle = <T>(arr: T[]): T[] => {\n  let currIdx = arr.length;\n\n  while (currIdx > 0) {\n    const randIdx = random(currIdx--);\n    [arr[currIdx], arr[randIdx]] = [arr[randIdx], arr[currIdx]];\n  }\n\n  return arr;\n};\n","import { random } from \"./random\";\n\nexport default class Vec2d {\n  constructor(readonly x: number, readonly y: number) {}\n\n  public add(v: Vec2d): Vec2d {\n    return new Vec2d(this.x + v.x, this.y + v.y);\n  }\n\n  public equals(v: Vec2d): boolean {\n    return this.x === v.x && this.y === v.y;\n  }\n\n  public toString(): string {\n    return `(${this.x}, ${this.y})`;\n  }\n\n  public static origin(): Vec2d {\n    return new Vec2d(0, 0);\n  }\n\n  public static random(from: Vec2d, to: Vec2d): Vec2d {\n    return new Vec2d(from.x + random(to.x - from.x), from.y + random(to.y - from.y));\n  }\n}\n","import Maze from \"./Maze\";\nimport Vec2d from \"../utils/Vec2d\";\n\nconst DIRECTIONS = [\n  { dx: 1, dy: 0 },\n  { dx: 0, dy: 1 },\n  { dx: -1, dy: 0 },\n  { dx: 0, dy: -1 },\n];\n\nconst getAdjacentPositions = (pos: Vec2d, dist: number): Vec2d[] =>\n  DIRECTIONS.map(({ dx, dy }) => pos.add(new Vec2d(dx * dist, dy * dist)));\n\nconst getAdjacentMazePositions = (maze: Maze, pos: Vec2d, dist: number): Vec2d[] =>\n  getAdjacentPositions(pos, dist).filter((pos) => maze.isWithinBounds(pos));\n\nexport const getAdjacentWallPositions = (maze: Maze, pos: Vec2d, dist: number = 1): Vec2d[] =>\n  getAdjacentMazePositions(maze, pos, dist).filter((pos) => maze.isWall(pos));\n\nexport const getAdjacentPathPositions = (maze: Maze, pos: Vec2d, dist: number = 1): Vec2d[] =>\n  getAdjacentMazePositions(maze, pos, dist).filter((pos) => !maze.isWall(pos));\n\nexport const findEmptySquareInBounds = (maze: Maze, from: Vec2d, to: Vec2d): Vec2d => {\n  let square;\n\n  do square = Vec2d.random(from, to);\n  while (maze.isWall(square));\n\n  return square;\n};\n","export default class CompoundSet<T> {\n  private set: Map<string, T>;\n\n  constructor(initial: T[] = []) {\n    this.set = new Map(initial.map((val) => [this.toKey(val), val]));\n  }\n\n  has(val: T): boolean {\n    return this.set.has(this.toKey(val));\n  }\n\n  add(val: T): this {\n    this.set.set(this.toKey(val), val);\n    return this;\n  }\n\n  delete(val: T): this {\n    this.set.delete(this.toKey(val));\n    return this;\n  }\n\n  [Symbol.iterator]() {\n    return this.set.values();\n  }\n\n  private toKey(val: T): string {\n    return JSON.stringify(val);\n  }\n}\n","export default class CompoundMap<K, V> implements Map<K, V> {\n  private readonly items: Map<string, { key: K; value: V }>;\n\n  constructor(entries: [K, V][] = []) {\n    this.items = new Map(\n      entries.map(([key, value]) => [this.toKey(key), { key, value }])\n    );\n  }\n\n  clear(): void {\n    this.items.clear();\n  }\n\n  delete(key: K): boolean {\n    return this.items.delete(this.toKey(key));\n  }\n\n  get(key: K): V | undefined {\n    return this.items.get(this.toKey(key))?.value;\n  }\n\n  has(key: K): boolean {\n    return this.items.has(this.toKey(key));\n  }\n\n  set(key: K, value: V): this {\n    this.items.set(this.toKey(key), { key, value });\n    return this;\n  }\n\n  *[Symbol.iterator](): IterableIterator<[K, V]> {\n    for (const [, { key, value }] of this.items) {\n      yield [key, value];\n    }\n  }\n\n  *entries(): IterableIterator<[K, V]> {\n    yield* this[Symbol.iterator]();\n  }\n\n  *keys(): IterableIterator<K> {\n    for (const [, { key }] of this.items) {\n      yield key;\n    }\n  }\n\n  *values(): IterableIterator<V> {\n    for (const [, { value }] of this.items) {\n      yield value;\n    }\n  }\n\n  forEach(callbackfn: (value: V, key: K, map: Map<K, V>) => void, thisArg?: any): void {\n    for (const [, { key, value }] of this.items) {\n      callbackfn.call(thisArg, value, key, this);\n    }\n  }\n\n  get size(): number {\n    return this.items.size;\n  }\n\n  get [Symbol.toStringTag](): string {\n    return this.constructor.name;\n  }\n\n  private toKey(key: K): string {\n    return JSON.stringify(key);\n  }\n}\n","import Maze from \"../Maze\";\nimport Vec2d from \"../../utils/Vec2d\";\nimport Set from \"../../utils/CompoundSet\";\nimport { shuffle } from \"../../utils/random\";\nimport { getAdjacentWallPositions } from \"../\";\n\nlet maze: Maze;\n\nconst generate = function* (cols: number, rows: number): Generator<Maze> {\n  const start = Vec2d.random(Vec2d.origin(), new Vec2d(cols, rows));\n  maze = Maze.full(cols, rows).toggleWall(start);\n  yield* dfs(start, new Set([start]));\n};\n\nconst dfs = function* (pos: Vec2d, visited: Set<Vec2d>): Generator<Maze> {\n  for (const neighbour of shuffle(getAdjacentWallPositions(maze, pos, 2))) {\n    if (!visited.has(neighbour)) {\n      yield (maze = maze.toggleWalls([neighbour, new Vec2d((pos.x + neighbour.x) / 2, (pos.y + neighbour.y) / 2)]));\n      yield* dfs(neighbour, visited.add(neighbour));\n    }\n  }\n};\n\nconst depthFirstSearch = { name: \"Depth-first search\", generate };\n\nexport default depthFirstSearch;\n","import Maze from \"../Maze\";\nimport Vec2d from \"../../utils/Vec2d\";\nimport { randomEven } from \"../../utils/random\";\n\nlet maze: Maze;\n\nconst generate = function* (cols: number, rows: number): Generator<Maze> {\n  maze = Maze.empty(cols, rows);\n\n  for (let col = 0; col < cols; ++col) {\n    yield (maze = maze.toggleWalls([new Vec2d(col, 0), new Vec2d(cols - col - 1, rows - 1)]));\n  }\n\n  for (let row = 1; row < rows - 1; ++row) {\n    yield (maze = maze.toggleWalls([new Vec2d(0, row), new Vec2d(cols - 1, rows - row - 1)]));\n  }\n\n  yield* divide(new Vec2d(1, 1), new Vec2d(cols - 2, rows - 2));\n};\n\nconst divide = function* (from: Vec2d, to: Vec2d): Generator<Maze> {\n  const width = to.x - from.x + 1;\n  const height = to.y - from.y + 1;\n\n  if (width < 3 || height < 3) {\n    return;\n  }\n\n  const vertical = width > height;\n  const xy = 1 + (vertical ? from.x + randomEven(width - 2) : from.y + randomEven(height - 2));\n  const gap = vertical ? new Vec2d(xy, from.y + randomEven(height)) : new Vec2d(from.x + randomEven(width), xy);\n  const wallFrom = vertical ? new Vec2d(xy, from.y) : new Vec2d(from.x, xy);\n  const wallTo = vertical ? new Vec2d(xy, to.y + 1) : new Vec2d(to.x + 1, xy);\n  const direction = vertical ? new Vec2d(0, 1) : new Vec2d(1, 0);\n\n  let pos = wallFrom;\n  while (!pos.equals(wallTo)) {\n    if (!pos.equals(gap)) {\n      yield (maze = maze.toggleWall(pos));\n    }\n    pos = pos.add(direction);\n  }\n\n  if (vertical) {\n    yield* divide(from, new Vec2d(wallTo.x - 1, to.y));\n    yield* divide(new Vec2d(wallTo.x + 1, from.y), to);\n  } else {\n    yield* divide(from, new Vec2d(to.x, wallTo.y - 1));\n    yield* divide(new Vec2d(from.x, wallTo.y + 1), to);\n  }\n};\n\nconst recursiveDivision = { name: \"Recursive division\", generate };\n\nexport default recursiveDivision;\n","import { SearchNode, SearchParams, SearchState, rewind as defaultRewind } from \"../\";\nimport { getAdjacentPathPositions } from \"../../maze\";\nimport Vec2d from \"../../utils/Vec2d\";\nimport Set from \"../../utils/CompoundSet\";\nimport Queue from \"./utils/Queue\";\n\nenum Direction {\n  Forward,\n  Backward,\n}\n\ntype BiDirSearchNode = {\n  node: SearchNode;\n  direction: Direction;\n};\n\nlet nodeHistory: BiDirSearchNode[];\n\nconst search = function* ({ maze, start, target }: SearchParams): Generator<SearchState> {\n  nodeHistory = [];\n\n  const queue = new Queue<BiDirSearchNode>([\n    {\n      node: { pos: start },\n      direction: Direction.Forward,\n    },\n    {\n      node: { pos: target },\n      direction: Direction.Backward,\n    },\n  ]);\n  const visitedForward = new Set<Vec2d>();\n  const visitedBackward = new Set<Vec2d>();\n\n  while (!queue.isEmpty()) {\n    const { node, direction } = queue.dequeue();\n    const pos = node.pos;\n    let found;\n\n    switch (direction) {\n      case Direction.Forward:\n        if (visitedForward.has(pos)) continue;\n        found = visitedBackward.has(pos);\n        visitedForward.add(pos);\n        break;\n\n      case Direction.Backward:\n        if (visitedBackward.has(pos)) continue;\n        found = visitedForward.has(pos);\n        visitedBackward.add(pos);\n        break;\n    }\n\n    yield {\n      current: node,\n      visited: new Set([...visitedForward, ...visitedBackward]),\n      found,\n    };\n\n    for (const neighbour of getAdjacentPathPositions(maze, pos)) {\n      const neighbourNode = {\n        node: {\n          pos: neighbour,\n          prev: node,\n        },\n        direction,\n      };\n\n      nodeHistory.push(neighbourNode);\n      queue.enqueue(neighbourNode);\n    }\n  }\n};\n\nconst rewind = (node: SearchNode): Vec2d[] => {\n  const intersection = nodeHistory\n    .filter(({ node: n }) => node.pos.equals(n.pos))\n    .sort(({ direction }) => (direction === Direction.Forward ? -1 : 1));\n\n  return [\n    ...defaultRewind(intersection[0].node),\n    ...defaultRewind(intersection[intersection.length - 1].node).reverse(),\n  ];\n};\n\nconst biDirBfs = { name: \"Bidirectional BFS\", search, rewind, isWeighted: false };\n\nexport default biDirBfs;\n","import Vec2d from \"../utils/Vec2d\";\nimport Set from \"../utils/CompoundSet\";\nimport Map from \"../utils/CompoundMap\";\n\nexport default class Maze {\n  private walls = new Set<Vec2d>();\n  private weights = new Map<Vec2d, number>();\n\n  private constructor(readonly numCols: number, readonly numRows: number) {}\n\n  public static empty(numCols: number, numRows: number): Maze {\n    return new Maze(numCols, numRows);\n  }\n\n  public static full(numCols: number, numRows: number): Maze {\n    const walls = [];\n\n    for (let row = 0; row < numRows; ++row) {\n      for (let col = 0; col < numCols; ++col) {\n        walls.push(new Vec2d(col, row));\n      }\n    }\n\n    return Maze.empty(numCols, numRows).toggleWalls(walls);\n  }\n\n  public isEmpty(pos: Vec2d): boolean {\n    return !this.isWall(pos) && !this.isWeight(pos);\n  }\n\n  public isWall(pos: Vec2d): boolean {\n    return this.walls.has(pos);\n  }\n\n  public toggleWall(pos: Vec2d): Maze {\n    return this.toggleWalls([pos]);\n  }\n\n  public toggleWalls(positions: Vec2d[]): Maze {\n    const maze = this.clone();\n\n    for (const pos of positions) {\n      if (!this.isWithinBounds(pos)) {\n        throw new Error(`Out of bounds: ${pos.toString()}`);\n      }\n\n      if (maze.isWall(pos)) {\n        maze.walls.delete(pos);\n      } else {\n        maze.walls.add(pos);\n      }\n    }\n\n    return maze;\n  }\n\n  public isWeight(pos: Vec2d): boolean {\n    return this.weights.has(pos);\n  }\n\n  public getWeight(pos: Vec2d): number | undefined {\n    return this.weights.get(pos);\n  }\n\n  public setWeight(pos: Vec2d, weight: number): Maze {\n    const maze = this.clone();\n    maze.weights.set(pos, weight);\n    maze.walls.delete(pos);\n    return maze;\n  }\n\n  public removeWeight(pos: Vec2d): Maze {\n    const maze = this.clone();\n    maze.weights.delete(pos);\n    return maze;\n  }\n\n  public clearWeights(): Maze {\n    const maze = this.clone();\n    maze.weights = new Map<Vec2d, number>();\n    return maze;\n  }\n\n  public isWithinBounds(pos: Vec2d): boolean {\n    return pos.x >= 0 && pos.y >= 0 && pos.x < this.numCols && pos.y < this.numRows;\n  }\n\n  private clone(): Maze {\n    const maze = Maze.empty(this.numCols, this.numRows);\n    maze.walls = new Set([...this.walls]);\n    maze.weights = new Map([...this.weights]);\n    return maze;\n  }\n}\n","import Maze from \"../Maze\";\nimport Vec2d from \"../../utils/Vec2d\";\nimport { randomElement } from \"../../utils/random\";\nimport { getAdjacentWallPositions, getAdjacentPathPositions } from \"../\";\n\nconst generate = function* (cols: number, rows: number): Generator<Maze> {\n  let maze = Maze.full(cols, rows);\n  const frontier = [Vec2d.random(Vec2d.origin(), new Vec2d(cols, rows))];\n\n  // eslint-disable-next-line no-loop-func\n  while (frontier.some((pos) => maze.isWall(pos))) {\n    // eslint-disable-next-line no-loop-func\n    const cell = randomElement(frontier.filter((pos) => maze.isWall(pos)));\n    maze = maze.toggleWall(cell);\n\n    const adjPath = getAdjacentPathPositions(maze, cell, 2);\n    if (adjPath.length > 0) {\n      const randomPath = randomElement(adjPath);\n      yield (maze = maze.toggleWall(new Vec2d((cell.x + randomPath.x) / 2, (cell.y + randomPath.y) / 2)));\n    }\n\n    frontier.push(...getAdjacentWallPositions(maze, cell, 2));\n  }\n};\n\nconst prims = { name: \"Prims\", generate };\n\nexport default prims;\n","import Maze from \"../Maze\";\nimport Vec2d from \"../../utils/Vec2d\";\nimport { random } from \"../../utils/random\";\n\nconst generate = function* (cols: number, rows: number): Generator<Maze> {\n  let maze = Maze.empty(cols, rows);\n\n  for (let row = 2; row < rows; row += 2) {\n    for (let col = 2; col < cols; col += 2) {\n      const wallLeftOrUp = [new Vec2d(col - 1, row), new Vec2d(col, row - 1)];\n      yield (maze = maze.toggleWalls([wallLeftOrUp[random(2)], new Vec2d(col - 1, row - 1)]));\n    }\n  }\n};\n\nconst binaryTree = { name: \"Binary tree\", generate };\n\nexport default binaryTree;\n","import Maze from \"../Maze\";\nimport prims from \"./prims\";\nimport binaryTree from \"./binary-tree\";\nimport depthFirstSearch from \"./depth-first-search\";\nimport recursiveDivision from \"./recursive-division\";\nimport random from \"./random\";\n\ntype MazeGenerator = {\n  name: string;\n  generate: (cols: number, rows: number) => Generator<Maze>;\n};\n\nconst generators: { [key: string]: MazeGenerator } = { prims, binaryTree, recursiveDivision, depthFirstSearch, random };\n\nexport default generators;\n","import Maze from \"../Maze\";\nimport Vec2d from \"../../utils/Vec2d\";\n\nconst WALL_PROBABILITY = 1 / 4;\n\nconst generate = function* (cols: number, rows: number): Generator<Maze> {\n  let maze = Maze.empty(cols, rows);\n\n  for (let row = 0; row < rows; ++row) {\n    for (let col = 0; col < cols; ++col) {\n      if (Math.random() < WALL_PROBABILITY) {\n        yield (maze = maze.toggleWall(new Vec2d(col, row)));\n      }\n    }\n  }\n};\n\nconst random = { name: \"Random\", generate };\n\nexport default random;\n","import Maze from \"../maze/Maze\";\nimport Vec2d from \"../utils/Vec2d\";\nimport Set from \"../utils/CompoundSet\";\n\nexport type SearchParams = {\n  maze: Maze;\n  start: Vec2d;\n  target: Vec2d;\n};\n\nexport type SearchNode = {\n  pos: Vec2d;\n  prev?: SearchNode;\n};\n\nexport type SearchState = {\n  current: SearchNode;\n  visited: Set<Vec2d>;\n  found: boolean;\n};\n\nexport const rewind = (node: SearchNode): Vec2d[] => {\n  const path = [];\n\n  while (node.prev) {\n    path.unshift(node.pos);\n    node = node.prev;\n  }\n\n  return path;\n};\n","export default class Queue<T> {\n  constructor(private items: T[] = []) {}\n\n  public enqueue(...items: T[]): void {\n    this.items.push(...items);\n  }\n\n  public dequeue(): T {\n    if (this.isEmpty()) {\n      throw new Error(\"Cannot dequeue empty queue\");\n    }\n\n    return this.items.shift() as T;\n  }\n\n  public isEmpty(): boolean {\n    return this.size === 0;\n  }\n\n  public get size(): number {\n    return this.items.length;\n  }\n}\n","import { SearchNode, SearchParams, SearchState, rewind } from \"../\";\nimport { getAdjacentPathPositions } from \"../../maze\";\nimport Vec2d from \"../../utils/Vec2d\";\nimport Set from \"../../utils/CompoundSet\";\nimport Queue from \"./utils/Queue\";\n\nconst search = function* ({ maze, start, target }: SearchParams): Generator<SearchState> {\n  const queue = new Queue<SearchNode>([{ pos: start }]);\n  const visited = new Set<Vec2d>();\n\n  while (!queue.isEmpty()) {\n    const node = queue.dequeue();\n    const pos = node.pos;\n\n    if (visited.has(pos)) {\n      continue;\n    }\n\n    yield {\n      current: node,\n      visited: visited.add(pos),\n      found: target.equals(pos),\n    };\n\n    for (const neighbour of getAdjacentPathPositions(maze, pos)) {\n      queue.enqueue({ pos: neighbour, prev: node });\n    }\n  }\n};\n\nconst breadthFirstSearch = { name: \"Breadth-first search\", search, rewind, isWeighted: false };\n\nexport default breadthFirstSearch;\n","import React, { useRef, useState } from \"react\";\nimport { findEmptySquareInBounds } from \"../maze\";\nimport Maze from \"../maze/Maze\";\nimport mazeGenerators from \"../maze/generators\";\nimport searchMethods from \"../search/methods\";\nimport Vec2d from \"../utils/Vec2d\";\nimport Set from \"../utils/CompoundSet\";\nimport sleep from \"./utils/sleep\";\nimport Controls from \"./Controls\";\nimport MazeComponent from \"./Maze\";\n\ntype PathFinderProps = {\n  mazeSize: {\n    cols: number;\n    rows: number;\n  };\n  mazeStyle: React.CSSProperties;\n};\n\nenum DragType {\n  None,\n  Start,\n  Target,\n  Weight,\n  Drawing,\n}\n\ntype Drag = {\n  type: DragType;\n  dragged: boolean;\n  pos?: Vec2d;\n};\n\nconst getInitialDrag = (): Drag => ({ type: DragType.None, dragged: false });\nconst getInitialMaze = (cols: number, rows: number) => Maze.empty(cols, rows);\nconst getInitialStart = (cols: number, rows: number) => new Vec2d(Math.floor(cols / 4) - 1, Math.floor(rows / 2));\nconst getInitialTarget = (cols: number, rows: number) => new Vec2d(cols - Math.floor(cols / 4), Math.floor(rows / 2));\nconst getInitialVisited = () => new Set<Vec2d>();\nconst getInitialSolution = () => new Set<Vec2d>();\n\nconst PathFinder = ({ mazeSize: { cols, rows }, mazeStyle }: PathFinderProps): JSX.Element => {\n  const [maze, setMaze] = useState(getInitialMaze(cols, rows));\n  const [start, setStart] = useState(getInitialStart(cols, rows));\n  const [target, setTarget] = useState(getInitialTarget(cols, rows));\n  const [visited, setVisited] = useState(getInitialVisited());\n  const [solution, setSolution] = useState(getInitialSolution());\n\n  const [drag, setDrag] = useState(getInitialDrag());\n  const beginDrag = (type: DragType, pos: Vec2d): void => setDrag({ type, dragged: false, pos });\n  const setDragPos = (pos: Vec2d): void => setDrag({ ...drag, dragged: true, pos });\n\n  const [, setFinishedAt] = useState(Date.now);\n  const [isGenerating, setIsGenerating] = useState(false);\n\n  const [mazeGenerator, setMazeGenerator] = useState(\"recursiveDivision\");\n  const [searchMethod, setSearchMethod] = useState(\"breadthFirstSearch\");\n\n  const currentSearch = useRef<Generator | null>(null);\n  const hasCurrentSearch = (): boolean => currentSearch.current !== null;\n  const setCurrentSearch = (s: Generator | null): void => void (currentSearch.current = s);\n\n  const _isSearching = useRef(false);\n  const isSearching = (): boolean => _isSearching.current;\n  const setIsSearching = (r: boolean): void => void (_isSearching.current = r);\n\n  const handleMouseUp = (pos: Vec2d): void => {\n    if (isSearching()) return;\n\n    if (maze.isWeight(pos) && !drag.dragged) {\n      setMaze(maze.setWeight(pos, (maze.getWeight(pos) as number) + 1));\n    }\n\n    setDrag(getInitialDrag());\n  };\n\n  const handleMouseDown = (pos: Vec2d): void => {\n    if (isSearching()) return;\n\n    if (pos.equals(start)) {\n      return beginDrag(DragType.Start, pos);\n    }\n\n    if (pos.equals(target)) {\n      return beginDrag(DragType.Target, pos);\n    }\n\n    if (maze.isWeight(pos)) {\n      return beginDrag(DragType.Weight, pos);\n    }\n\n    beginDrag(DragType.Drawing, pos);\n    setMaze(maze.toggleWall(pos));\n  };\n\n  const handleMouseEnter = (pos: Vec2d): void => {\n    if (drag.type === DragType.None) return;\n\n    const isStartOrTarget = pos.equals(start) || pos.equals(target);\n    const isEmpty = maze.isEmpty(pos);\n\n    switch (drag.type) {\n      case DragType.Start:\n      case DragType.Target:\n        if (isEmpty && !isStartOrTarget) {\n          drag.type === DragType.Start ? setStart(pos) : setTarget(pos);\n          setDragPos(pos);\n        }\n\n        break;\n\n      case DragType.Weight:\n        if (isEmpty && !isStartOrTarget && drag.pos !== undefined) {\n          setMaze(maze.setWeight(pos, maze.getWeight(drag.pos) as number).removeWeight(drag.pos));\n          setDragPos(pos);\n        }\n\n        break;\n\n      case DragType.Drawing:\n        if (!isStartOrTarget && (isEmpty || maze.isWall(pos))) {\n          setMaze(maze.toggleWall(pos));\n          setDragPos(pos);\n        }\n    }\n  };\n\n  const handleDoubleClick = (pos: Vec2d): void => {\n    if (!searchMethods[searchMethod].isWeighted || isSearching() || pos.equals(start) || pos.equals(target)) {\n      return;\n    }\n\n    setMaze(maze.isWeight(pos) ? maze.removeWeight(pos) : maze.setWeight(pos, 5));\n  };\n\n  const handleStartClick = async (): Promise<void> => {\n    setIsSearching(true);\n\n    if (!hasCurrentSearch()) {\n      setCurrentSearch(generateSearch());\n      setSolution(getInitialSolution());\n    }\n\n    let next;\n\n    do {\n      // @ts-ignore\n      next = currentSearch.current.next();\n      if (next.value) next.value();\n      if (!isSearching()) return;\n      await sleep(10);\n    } while (!next.done);\n\n    setCurrentSearch(null);\n    setIsSearching(false);\n    setFinishedAt(Date.now);\n  };\n\n  const generateSearch = function* (): Generator<() => void> {\n    const method = searchMethods[searchMethod];\n\n    for (const state of method.search({ maze, start, target })) {\n      yield () => setVisited(new Set([...state.visited]));\n\n      if (state.found) {\n        const solution = getInitialSolution();\n        setSolution(solution);\n\n        for (const pos of method.rewind(state.current)) {\n          yield () => setSolution(new Set([...solution.add(pos)]));\n        }\n\n        return;\n      }\n    }\n  };\n\n  const handleStopClick = (): void => setIsSearching(false);\n\n  const handleClearClick = (): void => {\n    setMaze(getInitialMaze(cols, rows));\n    setStart(getInitialStart(cols, rows));\n    setTarget(getInitialTarget(cols, rows));\n    setVisited(getInitialVisited());\n    setSolution(getInitialSolution());\n    setCurrentSearch(null);\n    setIsGenerating(false);\n    setIsSearching(false);\n  };\n\n  const handleGenerateClick = async (): Promise<void> => {\n    handleClearClick();\n    setIsGenerating(true);\n\n    const outOfBounds = new Vec2d(cols, rows);\n    setStart(outOfBounds);\n    setTarget(outOfBounds);\n\n    let finalMaze = maze;\n\n    for (const maze of mazeGenerators[mazeGenerator].generate(cols, rows)) {\n      setMaze(maze);\n      finalMaze = maze;\n      await sleep(10);\n    }\n\n    setStart(findEmptySquareInBounds(finalMaze, Vec2d.origin(), new Vec2d(Math.floor(cols / 3), rows)));\n    setTarget(findEmptySquareInBounds(finalMaze, new Vec2d(Math.floor((cols * 2) / 3), 0), new Vec2d(cols, rows)));\n    setIsGenerating(false);\n  };\n\n  const handleMazeGeneratorSelect = (e: any): void => setMazeGenerator(e.target.value);\n\n  const handleSearchMethodSelect = (e: any): void => {\n    if (!searchMethods[e.target.value].isWeighted) {\n      setMaze(maze.clearWeights());\n    }\n\n    setSearchMethod(e.target.value);\n  };\n\n  const getSquareClassName = (pos: Vec2d): string | undefined => {\n    if (maze.isWall(pos)) return \"is-wall\";\n    if (pos.equals(start)) return \"is-start\";\n    if (pos.equals(target)) return \"is-target\";\n    if (solution.has(pos)) return \"is-solution\";\n    if (visited.has(pos)) return \"is-visited\";\n  };\n\n  return (\n    <div\n      className={`PathFinder${\n        isGenerating ? \" is-generating is-\" + mazeGenerator : isSearching() ? \" is-searching\" : \"\"\n      }`}\n    >\n      <Controls\n        isGenerating={isGenerating}\n        isSearching={isSearching()}\n        isWeighted={searchMethods[searchMethod].isWeighted}\n        onStartClick={handleStartClick}\n        onStopClick={handleStopClick}\n        onClearClick={handleClearClick}\n        onGenerateClick={handleGenerateClick}\n        selectedMazeGenerator={mazeGenerator}\n        selectedSearchMethod={searchMethod}\n        onMazeGeneratorSelect={handleMazeGeneratorSelect}\n        onSearchMethodSelect={handleSearchMethodSelect}\n      />\n      <MazeComponent\n        maze={maze}\n        style={mazeStyle}\n        getSquareClassName={getSquareClassName}\n        onMouseUp={handleMouseUp}\n        onMouseDown={handleMouseDown}\n        onMouseEnter={handleMouseEnter}\n        onDoubleClick={handleDoubleClick}\n      />\n    </div>\n  );\n};\n\nexport default PathFinder;\n","import PriorityQueue from \"ts-priority-queue\";\nimport { SearchNode, SearchParams, SearchState, rewind } from \"../\";\nimport { getAdjacentPathPositions } from \"../../maze\";\nimport Vec2d from \"../../utils/Vec2d\";\nimport Set from \"../../utils/CompoundSet\";\n\nconst search = function* ({ maze, start, target }: SearchParams): Generator<SearchState> {\n  const queue = new PriorityQueue<SearchNode>({\n    comparator: (a, b) => manhattanDistance(a.pos, target) - manhattanDistance(b.pos, target),\n    initialValues: [{ pos: start }],\n  });\n  const visited = new Set<Vec2d>();\n\n  while (queue.length > 0) {\n    const node = queue.dequeue();\n    const pos = node.pos;\n\n    if (visited.has(pos)) {\n      continue;\n    }\n\n    yield {\n      current: node,\n      visited: visited.add(pos),\n      found: target.equals(pos),\n    };\n\n    for (const neighbour of getAdjacentPathPositions(maze, pos)) {\n      queue.queue({ pos: neighbour, prev: node });\n    }\n  }\n};\n\nconst manhattanDistance = (a: Vec2d, b: Vec2d): number => Math.abs(a.x - b.x) + Math.abs(a.y - b.y);\n\nconst greedyBestFirstSearch = { name: \"Greedy best-first search\", search, rewind, isWeighted: false };\n\nexport default greedyBestFirstSearch;\n","import PriorityQueue from \"ts-priority-queue\";\nimport { SearchNode, SearchParams, SearchState, rewind } from \"../\";\nimport { getAdjacentPathPositions } from \"../../maze\";\nimport Vec2d from \"../../utils/Vec2d\";\nimport Set from \"../../utils/CompoundSet\";\n\ntype DijkstraSearchNode = SearchNode & { distance: number };\n\nconst search = function* ({ maze, start, target }: SearchParams): Generator<SearchState> {\n  const queue = new PriorityQueue<DijkstraSearchNode>({\n    comparator: (a, b) => a.distance - b.distance,\n    initialValues: [{ pos: start, distance: 0 }],\n  });\n  const visited = new Set<Vec2d>();\n\n  while (queue.length > 0) {\n    const node = queue.dequeue();\n    const pos = node.pos;\n\n    if (visited.has(pos)) {\n      continue;\n    }\n\n    yield {\n      current: node,\n      visited: visited.add(pos),\n      found: target.equals(pos),\n    };\n\n    for (const neighbour of getAdjacentPathPositions(maze, pos)) {\n      queue.queue({\n        pos: neighbour,\n        prev: node,\n        distance: node.distance + (maze.getWeight(neighbour) || 1),\n      });\n    }\n  }\n};\n\nconst dijkstra = { name: \"Dijkstra\", search, rewind, isWeighted: true };\n\nexport default dijkstra;\n","import PriorityQueue from \"ts-priority-queue\";\nimport { SearchNode, SearchParams, SearchState, rewind } from \"../\";\nimport { getAdjacentPathPositions } from \"../../maze\";\nimport Vec2d from \"../../utils/Vec2d\";\nimport Set from \"../../utils/CompoundSet\";\n\ntype AStarSearchNode = SearchNode & {\n  distFromStart: number;\n  distToTarget: number;\n};\n\nconst search = function* ({ maze, start, target }: SearchParams): Generator<SearchState> {\n  const queue = new PriorityQueue<AStarSearchNode>({\n    comparator: (a, b) => a.distFromStart - b.distFromStart + a.distToTarget - b.distToTarget,\n    initialValues: [{ pos: start, distFromStart: 0, distToTarget: 0 }],\n  });\n  const visited = new Set<Vec2d>();\n\n  while (queue.length > 0) {\n    const node = queue.dequeue();\n\n    if (visited.has(node.pos)) {\n      continue;\n    }\n\n    yield {\n      current: node,\n      visited: visited.add(node.pos),\n      found: target.equals(node.pos),\n    };\n\n    for (const neighbour of getAdjacentPathPositions(maze, node.pos)) {\n      queue.queue({\n        pos: neighbour,\n        prev: node,\n        distFromStart: node.distFromStart + (maze.getWeight(neighbour) || 1),\n        distToTarget: euclideanDistance(neighbour, target),\n      });\n    }\n  }\n};\n\nconst euclideanDistance = (a: Vec2d, b: Vec2d): number =>\n  Math.sqrt(Math.abs(a.x - b.x) ** 2 + Math.abs(a.y - b.y) ** 2);\n\nconst aStar = { name: \"A*\", search, rewind, isWeighted: true };\n\nexport default aStar;\n","import { SearchNode, SearchParams, SearchState, rewind } from \"../\";\nimport { getAdjacentPathPositions } from \"../../maze\";\nimport Vec2d from \"../../utils/Vec2d\";\nimport Set from \"../../utils/CompoundSet\";\n\nconst search = function* (params: SearchParams): Generator<SearchState> {\n  yield* dfs({ pos: params.start }, new Set(), params);\n};\n\nconst dfs = function* (node: SearchNode, visited: Set<Vec2d>, params: SearchParams): Generator<SearchState> {\n  const pos = node.pos;\n\n  if (visited.has(pos)) {\n    return;\n  }\n\n  yield {\n    current: node,\n    visited: visited.add(pos),\n    found: params.target.equals(pos),\n  };\n\n  for (const neighbour of getAdjacentPathPositions(params.maze, pos)) {\n    yield* dfs({ pos: neighbour, prev: node }, visited, params);\n  }\n};\n\nconst depthFirstSearch = { name: \"Depth-first search\", search, rewind, isWeighted: false };\n\nexport default depthFirstSearch;\n","import { SearchNode, SearchParams, SearchState } from \"../\";\nimport breadthFirstSearch from \"./breadth-first-search\";\nimport biDirectionalBfs from \"./bidirectional-bfs\";\nimport greedBestFirstSearch from \"./greedy-best-first-search\";\nimport dijkstra from \"./dijkstra\";\nimport aStar from \"./a-star\";\nimport depthFirstSearch from \"./depth-first-search\";\nimport Vec2d from \"../../utils/Vec2d\";\n\ntype SearchMethod = {\n  name: string;\n  search: (params: SearchParams) => Generator<SearchState>;\n  rewind: (node: SearchNode) => Vec2d[];\n  isWeighted: boolean;\n};\n\nconst methods: { [key: string]: SearchMethod } = {\n  breadthFirstSearch,\n  biDirectionalBfs,\n  greedBestFirstSearch,\n  dijkstra,\n  aStar,\n  depthFirstSearch,\n};\n\nexport default methods;\n","const sleep = async (ms: number): Promise<void> => {\n  await new Promise((r) => setTimeout(r, ms));\n};\n\nexport default sleep;\n","import { FormEvent } from \"react\";\nimport mazeGenerators from \"../maze/generators\";\nimport searchMethods from \"../search/methods\";\n\ntype ControlsProps = {\n  isGenerating: boolean;\n  isSearching: boolean;\n  isWeighted: boolean;\n  onStartClick: () => void;\n  onStopClick: () => void;\n  onClearClick: () => void;\n  onGenerateClick: () => void;\n  selectedMazeGenerator: string;\n  selectedSearchMethod: string;\n  onMazeGeneratorSelect: (e: FormEvent<HTMLSelectElement>) => void;\n  onSearchMethodSelect: (e: FormEvent<HTMLSelectElement>) => void;\n};\n\nconst Controls = (props: ControlsProps): JSX.Element => (\n  <div className=\"Controls\">\n    <fieldset id=\"maze-generator\">\n      <legend>Maze generator</legend>\n      <select onChange={props.onMazeGeneratorSelect} value={props.selectedMazeGenerator}>\n        {Object.entries(mazeGenerators).map(([key, generator]) => (\n          <option key={key} value={key}>\n            {generator.name}\n          </option>\n        ))}\n      </select>\n      <button onClick={props.onGenerateClick} disabled={props.isSearching || props.isGenerating}>\n        Generate\n      </button>\n      <button onClick={props.onClearClick} disabled={props.isSearching || props.isGenerating}>\n        Clear\n      </button>\n    </fieldset>\n    <fieldset id=\"search-method\">\n      <legend>Search method</legend>\n      <select onChange={props.onSearchMethodSelect} value={props.selectedSearchMethod}>\n        {Object.entries(searchMethods).map(([key, method]) => (\n          <option key={key} value={key}>\n            {method.name}\n          </option>\n        ))}\n      </select>\n      {props.isWeighted && (\n        <em>\n          <small>Double click to add weights!</small>\n        </em>\n      )}\n      <button onClick={props.isSearching ? props.onStopClick : props.onStartClick} disabled={props.isGenerating}>\n        {props.isSearching ? \"Stop\" : \"Search\"}\n      </button>\n    </fieldset>\n  </div>\n);\n\nexport default Controls;\n","import React from \"react\";\nimport Maze from \"../maze/Maze\";\nimport Vec2d from \"../utils/Vec2d\";\n\ntype MazeProps = {\n  maze: Maze;\n  style: React.CSSProperties;\n  getSquareClassName: (pos: Vec2d) => string | undefined;\n  onMouseUp: (pos: Vec2d) => void;\n  onMouseDown: (pos: Vec2d) => void;\n  onMouseEnter: (pos: Vec2d) => void;\n  onDoubleClick: (pos: Vec2d) => void;\n};\n\nconst MazeComponent = (props: MazeProps): JSX.Element => {\n  const squares = [];\n\n  for (let row = 0; row < props.maze.numRows; ++row) {\n    for (let col = 0; col < props.maze.numCols; ++col) {\n      const pos = new Vec2d(col, row);\n\n      squares.push(\n        <div\n          key={pos.toString()}\n          className={props.getSquareClassName(pos)}\n          data-weight={props.maze.getWeight(pos)}\n          onMouseUp={() => props.onMouseUp(pos)}\n          onMouseDown={() => props.onMouseDown(pos)}\n          onMouseEnter={() => props.onMouseEnter(pos)}\n          onDoubleClick={() => props.onDoubleClick(pos)}\n        />\n      );\n    }\n  }\n\n  return (\n    <div className=\"Maze\" style={props.style}>\n      {squares}\n    </div>\n  );\n};\n\nexport default MazeComponent;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport PathFinder from \"./Components/PathFinder\";\nimport \"./index.css\";\n\nconst isEmbedMode = () => window.location.search.indexOf(\"embed\") !== -1;\n\nif (isEmbedMode()) {\n  const colourScheme =\n    \":root{--nc-tx-1:#000000;--nc-tx-2:#1A1A1A;--nc-bg-1:#FFFFFF;--nc-bg-2:#F6F8FA;--nc-bg-3:#E5E7EB;--nc-lk-1:#0070F3;--nc-lk-2:#0366D6;--nc-lk-tx:#FFFFFF;--nc-ac-1:#79FFE1;--nc-ac-tx:#0C4047}\";\n  const hiddenElems =\n    \"header,#maze-generator legend,#maze-generator select,#search-method legend,#search-method select{display:none}\";\n  const tweaks =\n    \":root{--square-width:24px}body{padding:0}.Controls{display:flex;margin-bottom:0}.Controls>fieldset,.Controls>fieldset>*{margin-right:1rem}#maze-generator,#search-method{padding:0;border:none}.Maze>.is-start{background-image:var(--start-light-bg)}\";\n\n  const style = document.createElement(\"style\");\n  style.appendChild(document.createTextNode(colourScheme + hiddenElems + tweaks));\n  (document.head || document.getElementsByTagName(\"head\")[0]).appendChild(style);\n}\n\nconst buildPathFinderProps = () => {\n  const mazeSize = getSizeFromUrl();\n  const squareWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue(\"--square-width\"));\n\n  if (mazeSize.cols === null) {\n    const bodyPadding = isEmbedMode() ? 0 : parseInt(getComputedStyle(document.body).getPropertyValue(\"padding-left\"));\n    // @ts-ignore\n    mazeSize.cols = Math.floor((window.innerWidth - 2 * bodyPadding) / squareWidth);\n  }\n\n  if (mazeSize.rows === null) {\n    const headerHeight = isEmbedMode()\n      ? 30\n      : // @ts-ignore\n        parseInt(getComputedStyle(document.querySelector(\"header\")).getPropertyValue(\"height\"));\n\n    // @ts-ignore\n    mazeSize.rows = Math.max(5, Math.floor((window.innerHeight - 3 * headerHeight) / squareWidth));\n  }\n\n  return {\n    mazeSize,\n    mazeStyle: {\n      gridTemplateColumns: `repeat(${mazeSize.cols}, ${squareWidth}px)`,\n      gridTemplateRows: `repeat(${mazeSize.rows}, ${squareWidth}px)`,\n    },\n  };\n};\n\nconst getSizeFromUrl = () => {\n  const size = {\n    cols: null,\n    rows: null,\n  };\n\n  const params = new URLSearchParams(window.location.search);\n\n  // @ts-ignore\n  if (params.has(\"cols\")) size.cols = parseInt(params.get(\"cols\"));\n  // @ts-ignore\n  if (params.has(\"rows\")) size.rows = parseInt(params.get(\"rows\"));\n\n  return size;\n};\n\nReactDOM.render(\n  <React.StrictMode>\n    {/*\n    // @ts-ignore */}\n    <PathFinder {...buildPathFinderProps()} />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n"],"sourceRoot":""}